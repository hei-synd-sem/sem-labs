-- VHDL Entity Board.pipelineCounter_circuit.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 08:53:13 03/11/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY pipelineCounter_circuit IS
   GENERIC( 
      counterBitNb : positive := 16
   );
   PORT( 
      clock    : IN     std_ulogic;
      reset_N  : IN     std_ulogic;
      countOut : OUT    unsigned (counterBitNb-1 DOWNTO 0)
   );

-- Declarations

END pipelineCounter_circuit ;





-- VHDL Entity PipelinedOperators.pipelineCounter.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 08:50:00 03/11/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY pipelineCounter IS
   GENERIC( 
      bitNb   : positive;
      stageNb : positive
   );
   PORT( 
      countOut : OUT    unsigned (bitNb-1 DOWNTO 0);
      clock    : IN     std_ulogic;
      reset    : IN     std_ulogic
   );

-- Declarations

END pipelineCounter ;





-- VHDL Entity PipelinedOperators.pipelineAdder.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 08:50:15 03/11/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY pipelineAdder IS
   GENERIC( 
      bitNb   : positive;
      stageNb : positive
   );
   PORT( 
      sum   : OUT    signed (bitNb-1 DOWNTO 0);
      clock : IN     std_ulogic;
      reset : IN     std_ulogic;
      cIn   : IN     std_ulogic;
      cOut  : OUT    std_ulogic;
      a     : IN     signed (bitNb-1 DOWNTO 0);
      b     : IN     signed (bitNb-1 DOWNTO 0)
   );

-- Declarations

END pipelineAdder ;





-- VHDL Entity PipelinedOperators.parallelAdder.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 09:08:41 10/18/21
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY parallelAdder IS
   GENERIC( 
      bitNb : positive := 32
   );
   PORT( 
      sum  : OUT    signed (bitNb-1 DOWNTO 0);
      cIn  : IN     std_ulogic;
      cOut : OUT    std_ulogic;
      a    : IN     signed (bitNb-1 DOWNTO 0);
      b    : IN     signed (bitNb-1 DOWNTO 0)
   );

-- Declarations

END parallelAdder ;





ARCHITECTURE masterVersion OF parallelAdder IS

  signal sum_int: unsigned(sum'high+1 downto 0);

BEGIN

  sum_int <= resize(unsigned(a), sum_int'length) +
             resize(unsigned(b), sum_int'length) +
             resize('0' & cIn, sum_int'length);

  sum <= signed(sum_int(sum'range));
  cOut <= sum_int(sum_int'high);

END ARCHITECTURE masterVersion;





ARCHITECTURE masterVersion OF pipelineAdder IS

  constant stageBitNb : positive := sum'length/stageNb;
  subtype stageOperandType is signed(stageBitNb-1 downto 0);
  type stageOperandVectorType is array(stageNb-1 downto 0) of stageOperandType;
  type stageOperandMatrixType is array(stageNb-1 downto 0) of stageOperandVectorType;
  subtype carryType is std_ulogic_vector(stageNb downto 0);

  signal a_int, b_int, sum_int : stageOperandMatrixType;
  signal carryIn, carryOut : carryType;

  COMPONENT parallelAdder
  GENERIC (
    bitNb : positive := 32
  );
  PORT (
    sum  : OUT    signed (bitNb-1 DOWNTO 0);
    cIn  : IN     std_ulogic ;
    cOut : OUT    std_ulogic ;
    a    : IN     signed (bitNb-1 DOWNTO 0);
    b    : IN     signed (bitNb-1 DOWNTO 0)
  );
  END COMPONENT;

BEGIN

  carryIn(0) <= cIn;

  distributeInput: for wordIndex in stageOperandVectorType'range generate
    a_int(wordIndex)(0) <= a(wordIndex*stageBitNb+stageBitNb-1 downto wordIndex*stageBitNb);
    b_int(wordIndex)(0) <= b(wordIndex*stageBitNb+stageBitNb-1 downto wordIndex*stageBitNb);
  end generate distributeInput;

  inputRegistersX: for wordIndex in stageOperandVectorType'high downto 1 generate
    inputRegistersY: for pipeIndex in stageOperandMatrixType'high downto 1 generate
      upperTriangle: if wordIndex >= pipeIndex generate
        inputRegisters: process(reset, clock)
        begin
          if reset = '1' then
            a_int(wordIndex)(pipeIndex) <= (others => '0');
            b_int(wordIndex)(pipeIndex) <= (others => '0');
          elsif rising_edge(clock) then
            a_int(wordIndex)(pipeIndex) <= a_int(wordIndex)(pipeIndex-1);
            b_int(wordIndex)(pipeIndex) <= b_int(wordIndex)(pipeIndex-1);
          end if;
        end process inputRegisters;
      end generate upperTriangle;
    end generate inputRegistersY;
  end generate inputRegistersX;

  operation: for index in stageOperandVectorType'range generate
    partialAdder: parallelAdder
      GENERIC MAP (bitNb => stageBitNb)
      PORT MAP (
         a    => a_int(index)(index),
         b    => b_int(index)(index),
         sum  => sum_int(index)(index),
         cIn  => carryIn(index),
         cOut => carryOut(index)
      );
      carryRegisters: process(reset, clock)
      begin
        if reset = '1' then
          carryIn(index+1) <= '0';
        elsif rising_edge(clock) then
          carryIn(index+1) <= carryOut(index);
        end if;
      end process carryRegisters;
  end generate operation;

  outputRegistersX: for wordIndex in stageOperandVectorType'range generate
    outputRegistersY: for pipeIndex in stageOperandMatrixType'range generate
      lowerTriangle: if wordIndex < pipeIndex generate
        outputRegisters: process(reset, clock)
        begin
          if reset = '1' then
            sum_int(wordIndex)(pipeIndex) <= (others => '0');
          elsif rising_edge(clock) then
            sum_int(wordIndex)(pipeIndex) <= sum_int(wordIndex)(pipeIndex-1);
          end if;
        end process outputRegisters;
      end generate lowerTriangle;
    end generate outputRegistersY;
  end generate outputRegistersX;

  packOutput: for index in stageOperandVectorType'range generate
    sum(index*stageBitNb+stageBitNb-1 downto index*stageBitNb) <=
      sum_int(index)(stageOperandMatrixType'high);
  end generate packOutput;

  cOut <= carryOut(carryOut'high-1);

END ARCHITECTURE masterVersion;




ARCHITECTURE masterVersion OF pipelineCounter IS

  signal initCounter : unsigned(countOut'length/stageNb-1 downto 0);
  signal b : signed(countOut'range);
  signal sum : signed(countOut'range);

  COMPONENT pipelineAdder
  GENERIC (
    bitNb   : positive := 32;
    stageNb : positive := 4
  );
  PORT (
    reset : IN     std_ulogic;
    clock : IN     std_ulogic;
    cIn   : IN     std_ulogic;
    a     : IN     signed (bitNb-1 DOWNTO 0);
    b     : IN     signed (bitNb-1 DOWNTO 0);
    sum   : OUT    signed (bitNb-1 DOWNTO 0);
    cOut  : OUT    std_ulogic
  );
  END COMPONENT;

BEGIN

  adder: pipelineAdder
    GENERIC MAP (
      bitNb => countOut'length,
      stageNb => stageNb
      )
    PORT MAP (
       reset => reset,
       clock => clock,
       cIn   => '0',
       a     => sum,
       b     => b,
       sum   => sum,
       cOut  => open
    );

  prepareBInput: process(reset, clock)
  begin
    if reset = '1' then
      initCounter <= (others => '0');
    elsif rising_edge(clock) then
      if initCounter < stageNb then
        initCounter <= initCounter + 1;
      end if;
    end if;
  end process prepareBInput;

  selectInitOrRun: process(initCounter, sum)
  begin
    if initCounter < stageNb-1 then
      b <= signed(resize(initCounter+stageNb-1, b'length));
      countOut <= resize(initCounter, countOut'length);
    else
      b <= to_signed(stageNb-1, b'length);
      countOut <= unsigned(sum);
    end if;
  end process selectInitOrRun;

END ARCHITECTURE masterVersion;




-- VHDL Entity Board.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:05 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY DFF IS
   PORT( 
      CLK : IN     std_uLogic;
      CLR : IN     std_uLogic;
      D   : IN     std_uLogic;
      Q   : OUT    std_uLogic
   );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0';
    elsif rising_edge(clk) then
      q <= d;
    end if;
  end process;

END ARCHITECTURE sim;





-- VHDL Entity Board.inverterIn.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:14 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY inverterIn IS
   PORT( 
      in1  : IN     std_uLogic;
      out1 : OUT    std_uLogic
   );

-- Declarations

END inverterIn ;





ARCHITECTURE sim OF inverterIn IS
BEGIN

  out1 <= NOT in1;

END ARCHITECTURE sim;





--
-- VHDL Architecture Board.pipelineCounter_circuit.struct
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 08:53:13 03/11/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY Board;
-- LIBRARY PipelinedOperators;

ARCHITECTURE struct OF pipelineCounter_circuit IS

   -- Architecture declarations
   -- constant counterBitNb: positive := 20;
   constant pipelineStageNb: positive := 5;

   -- Internal signal declarations
   SIGNAL logic1      : std_uLogic;
   SIGNAL reset       : std_ulogic;
   SIGNAL resetSnch_N : std_ulogic;
   SIGNAL resetSynch  : std_ulogic;


   -- Component Declarations
   COMPONENT DFF
   PORT (
      CLK : IN     std_uLogic ;
      CLR : IN     std_uLogic ;
      D   : IN     std_uLogic ;
      Q   : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT inverterIn
   PORT (
      in1  : IN     std_uLogic ;
      out1 : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT pipelineCounter
   GENERIC (
      bitNb   : positive;
      stageNb : positive
   );
   PORT (
      countOut : OUT    unsigned (bitNb-1 DOWNTO 0);
      clock    : IN     std_ulogic ;
      reset    : IN     std_ulogic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
--    FOR ALL : DFF USE ENTITY Board.DFF;
--    FOR ALL : inverterIn USE ENTITY Board.inverterIn;
--    FOR ALL : pipelineCounter USE ENTITY PipelinedOperators.pipelineCounter;
   -- pragma synthesis_on


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 4 eb4
   logic1 <= '1';


   -- Instance port mappings.
   I_dff : DFF
      PORT MAP (
         CLK => clock,
         CLR => reset,
         D   => logic1,
         Q   => resetSnch_N
      );
   I_inv1 : inverterIn
      PORT MAP (
         in1  => reset_N,
         out1 => reset
      );
   I_inv2 : inverterIn
      PORT MAP (
         in1  => resetSnch_N,
         out1 => resetSynch
      );
   I_cnt : pipelineCounter
      GENERIC MAP (
         bitNb   => counterBitNb,
         stageNb => pipelineStageNb
      )
      PORT MAP (
         countOut => countOut,
         clock    => clock,
         reset    => resetSynch
      );

END struct;




