-- VHDL Entity Board.FPGA_beamer.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:26:55 04/15/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FPGA_beamer IS
    GENERIC( 
        memAddressBitNb : positive := 24;
        memDataBitNb    : positive := 16
    );
    PORT( 
        clock       : IN     std_ulogic;
        reset_N     : IN     std_ulogic;
        rxd0        : IN     std_ulogic;
        selSinCos_n : IN     std_ulogic;
        LED1        : OUT    std_ulogic;
        LED2        : OUT    std_ulogic;
        spare       : OUT    std_ulogic_vector (1 TO 17);
        txd0        : OUT    std_ulogic;
        xOut        : OUT    std_ulogic;
        yOut        : OUT    std_ulogic
    );

-- Declarations

END FPGA_beamer ;





-- VHDL Entity Board.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:05 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY DFF IS
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        D   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0';
    elsif rising_edge(clk) then
      q <= d;
    end if;
  end process;

END ARCHITECTURE sim;





-- VHDL Entity Board.inverterIn.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:14 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY inverterIn IS
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END inverterIn ;





ARCHITECTURE sim OF inverterIn IS
BEGIN

  out1 <= NOT in1;

END ARCHITECTURE sim;





-- VHDL Entity SystemOnChip.beamerSoc.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:20 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY beamerSoc IS
    GENERIC( 
        ioNb                : positive := 8;
        testOutBitNb        : positive := 16;
        patternAddressBitNb : positive := 9
    );
    PORT( 
        TxD       : OUT    std_ulogic;
        RxD       : IN     std_ulogic;
        outX      : OUT    std_ulogic;
        outY      : OUT    std_ulogic;
        selSinCos : IN     std_ulogic;
        reset     : IN     std_ulogic;
        clock     : IN     std_ulogic;
        ioEn      : OUT    std_ulogic_vector (ioNb-1 DOWNTO 0);
        ioOut     : OUT    std_ulogic_vector (ioNb-1 DOWNTO 0);
        ioIn      : IN     std_ulogic_vector (ioNb-1 DOWNTO 0);
        testOut   : OUT    std_ulogic_vector (1 TO testOutBitNb)
    );

-- Declarations

END beamerSoc ;





LIBRARY ieee;
  USE ieee.std_logic_1164.all;

PACKAGE ahbLite IS
  ------------------------------------------------------------------------------
                                                         -- bus components sizes
  constant ahbAddressBitNb  : positive := 16;
  constant ahbDataBitNb     : positive := 16;
  constant ahbSlaveNb       : positive := 16;

  constant ahbTransBitNb    : positive := 2;
  constant ahbSizeBitNb     : positive := 1;
  constant ahbBurstBitNb    : positive := 3;
  constant ahbProtBitNb     : positive := 4;

  ------------------------------------------------------------------------------
                                                         -- bus data vector type
  subtype ahbDataType is std_logic_vector(ahbDataBitNb-1 downto 0);
  type ahbDataVector is array(1 to ahbSlaveNb) of ahbDataType;

  ------------------------------------------------------------------------------
                                                              -- address decoder
  type ahbMemoryLocationType is
    record
      baseAddress: natural;
      addressMask: natural;
    end record;
  type ahbMemoryLocationVector is array(1 to ahbSlaveNb) of ahbMemoryLocationType;

  ------------------------------------------------------------------------------
                                                                  -- bus signals
  subtype transferType is std_ulogic_vector(ahbTransBitNb-1 downto 0);
  constant transIdle  : transferType := "00";
  constant transBusy  : transferType := "01";
  constant transNonSeq: transferType := "10";
  constant transSeq   : transferType := "11";

  subtype transferSizeType is std_ulogic_vector(ahbSizeBitNb-1 downto 0);
  constant size8   : transferSizeType := "0";
  constant size16  : transferSizeType := "1";

  subtype burstType is std_ulogic_vector(ahbBurstBitNb-1 downto 0);
  constant burstSingle : burstType := "000";
  constant burstIncr   : burstType := "001";
  constant burstWrap4  : burstType := "010";
  constant burstIncr4  : burstType := "011";
  constant burstWrap8  : burstType := "100";
  constant burstIncr8  : burstType := "101";
  constant burstWrap16 : burstType := "110";
  constant burstIncr16 : burstType := "111";

  subtype protectionType is std_ulogic_vector(ahbProtBitNb-1 downto 0);
  constant protDefault : protectionType := "0011";

  ------------------------------------------------------------------------------
                                                                         -- log2
  function addressBitNb (addressNb : natural) return natural;

END ahbLite;




PACKAGE BODY ahbLite IS

  function addressBitNb (addressNb : natural) return natural is
    variable powerOfTwo, bitNb : natural;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= addressNb loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end addressBitNb;

END ahbLite;




-- VHDL Entity SystemOnChip.ahbBeamer.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:22 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY AhbLite;
  use work.ahbLite.all;

ENTITY ahbBeamer IS
    GENERIC( 
        patternAddressBitNb : positive := 9;
        testOutBitNb        : positive := 16
    );
    PORT( 
        outX      : OUT    std_ulogic;
        hAddr     : IN     unsigned (ahbAddressBitNb-1 DOWNTO 0);
        outY      : OUT    std_ulogic;
        hWData    : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        selSinCos : IN     std_ulogic;
        testOut   : OUT    std_ulogic_vector (1 TO testOutBitNb);
        hRData    : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hTrans    : IN     std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWrite    : IN     std_ulogic;
        hSel      : IN     std_ulogic;
        hReady    : OUT    std_ulogic;
        hResp     : OUT    std_ulogic;
        hClk      : IN     std_ulogic;
        hReset_n  : IN     std_ulogic
    );

-- Declarations

END ahbBeamer ;





-- VHDL Entity SystemOnChip.ahbBeamerOperator.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:21 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY ahbBeamerOperator IS
    GENERIC( 
        updatePeriodBitNb : positive := 16;
        signalBitNb       : positive := 16
    );
    PORT( 
        outX           : OUT    std_ulogic;
        run            : IN     std_ulogic;
        clock          : IN     std_ulogic;
        reset          : IN     std_ulogic;
        outY           : OUT    std_ulogic;
        selSinCos      : IN     std_ulogic;
        interpolateLin : IN     std_ulogic;
        updatePeriod   : IN     unsigned (updatePeriodBitNb-1 DOWNTO 0);
        memX           : IN     std_ulogic_vector (signalBitNb-1 DOWNTO 0);
        memY           : IN     std_ulogic_vector (signalBitNb-1 DOWNTO 0);
        newPolynom     : OUT    std_ulogic
    );

-- Declarations

END ahbBeamerOperator ;





-- VHDL Entity SplineInterpolator.interpolatorCoefficients.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:00:20 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY interpolatorCoefficients IS
    GENERIC( 
        bitNb      : positive := 16;
        coeffBitNb : positive := 16
    );
    PORT( 
        sample1           : IN     signed (bitNb-1 DOWNTO 0);
        sample2           : IN     signed (bitNb-1 DOWNTO 0);
        sample3           : IN     signed (bitNb-1 DOWNTO 0);
        sample4           : IN     signed (bitNb-1 DOWNTO 0);
        a                 : OUT    signed (coeffBitNb-1 DOWNTO 0);
        b                 : OUT    signed (coeffBitNb-1 DOWNTO 0);
        c                 : OUT    signed (coeffBitNb-1 DOWNTO 0);
        d                 : OUT    signed (coeffBitNb-1 DOWNTO 0);
        interpolateLinear : IN     std_ulogic
    );

-- Declarations

END interpolatorCoefficients ;





ARCHITECTURE masterVersion OF interpolatorCoefficients IS
BEGIN

  calcCoeffs: process(interpolateLinear, sample1, sample2, sample3, sample4)
  begin
    if interpolateLinear = '1' then
      a <= (others => '0');
      b <= (others => '0');
      c <=   resize(2*sample3, c'length)
           - resize(2*sample2, c'length);
      d <=   resize(  sample2, d'length);
    else
      a <=   resize(  sample4, a'length)
           - resize(3*sample3, a'length)
           + resize(3*sample2, a'length)
           - resize(  sample1, a'length);
      b <=   resize(2*sample1, b'length)
           - resize(5*sample2, b'length)
           + resize(4*sample3, b'length)
           - resize(  sample4, b'length);
      c <=   resize(  sample3, c'length)
           - resize(  sample1, c'length);
      d <=   resize(  sample2, d'length);
    end if;
  end process calcCoeffs;

END ARCHITECTURE masterVersion;





-- VHDL Entity DigitalToAnalogConverter.DAC.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:06:08 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY DAC IS
    GENERIC( 
        signalBitNb : positive := 16
    );
    PORT( 
        serialOut  : OUT    std_ulogic;
        parallelIn : IN     unsigned (signalBitNb-1 DOWNTO 0);
        clock      : IN     std_ulogic;
        reset      : IN     std_ulogic
    );

-- Declarations

END DAC ;





ARCHITECTURE masterVersion OF DAC IS

  signal parallelIn1: unsigned(parallelIn'range);
  signal integrator: unsigned(parallelIn'high+1 downto 0);
  signal quantized: std_ulogic;

BEGIN

--  parallelIn1 <= parallelIn;
  parallelIn1 <= parallelIn/2 + 2**(parallelIn'length-2);

  integrate: process(reset, clock)
  begin
    if reset = '1' then
      integrator <= (others => '0');
    elsif rising_edge(clock) then
      if quantized = '0' then
        integrator <= integrator + parallelIn1;
      else
        integrator <= integrator + parallelIn1 - 2**parallelIn'length;
      end if;
    end if;
  end process integrate;

  quantized <= integrator(integrator'high);

  serialOut <= quantized;

END ARCHITECTURE masterVersion;




-- VHDL Entity SplineInterpolator.offsetToUnsigned.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:00:32 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY offsetToUnsigned IS
    GENERIC( 
        bitNb : positive := 16
    );
    PORT( 
        unsignedOut : OUT    unsigned (bitNb-1 DOWNTO 0);
        signedIn    : IN     signed (bitNb-1 DOWNTO 0)
    );

-- Declarations

END offsetToUnsigned ;





ARCHITECTURE masterVersion OF offsetToUnsigned IS

BEGIN

  unsignedOut <= not(signedIn(signedIn'high)) & unsigned(signedIn(signedIn'high-1 downto 0));

END ARCHITECTURE masterVersion;




-- VHDL Entity WaveformGenerator.sawtoothGen.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 08:02:49 03/11/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY sawtoothGen IS
    GENERIC( 
        bitNb : positive := 16
    );
    PORT( 
        sawtooth : OUT    unsigned (bitNb-1 DOWNTO 0);
        clock    : IN     std_ulogic;
        reset    : IN     std_ulogic;
        step     : IN     unsigned (bitNb-1 DOWNTO 0);
        en       : IN     std_ulogic
    );

-- Declarations

END sawtoothGen ;





ARCHITECTURE masterVersion OF sawtoothGen IS

  signal counter: unsigned(sawtooth'range);

begin

  count: process(reset, clock)
  begin
    if reset = '1' then
      counter <= (others => '0');
    elsif rising_edge(clock) then
      if en = '1' then
        counter <= counter + step;
      end if;
    end if;
  end process count;

  sawtooth <= counter;

END ARCHITECTURE masterVersion;





-- VHDL Entity SplineInterpolator.interpolatorCalculatePolynom.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:00:14 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY interpolatorCalculatePolynom IS
    GENERIC( 
        signalBitNb       : positive := 16;
        coeffBitNb        : positive := 16;
        oversamplingBitNb : positive := 8
    );
    PORT( 
        clock          : IN     std_ulogic;
        reset          : IN     std_ulogic;
        restartPolynom : IN     std_ulogic;
        d              : IN     signed (coeffBitNb-1 DOWNTO 0);
        sampleOut      : OUT    signed (signalBitNb-1 DOWNTO 0);
        c              : IN     signed (coeffBitNb-1 DOWNTO 0);
        b              : IN     signed (coeffBitNb-1 DOWNTO 0);
        a              : IN     signed (coeffBitNb-1 DOWNTO 0);
        en             : IN     std_ulogic
    );

-- Declarations

END interpolatorCalculatePolynom ;





ARCHITECTURE masterVersion OF interpolatorCalculatePolynom IS

  constant additionalBitNb: positive := 1;
  constant internalsBitNb: positive := signalBitNb + 3*oversamplingBitNb + 1
    + additionalBitNb;
  signal x: signed(internalsBitNb-1 downto 0);
  signal u: signed(internalsBitNb-1 downto 0);
  signal v: signed(internalsBitNb-1 downto 0);
  signal w: signed(internalsBitNb-1 downto 0);

BEGIN

  iterativePolynom: process(reset, clock)
  begin
    if reset = '1' then
      x <= (others => '0');
      u <= (others => '0');
      v <= (others => '0');
      w <= (others => '0');
      sampleOut <= (others => '0');
    elsif rising_edge(clock) then
      if en = '1' then
        if restartPolynom = '1' then
          x <=   shift_left(resize(2*d, x'length), 3*oversamplingBitNb);
          u <=   resize(a, u'length)
               + shift_left(resize(b, u'length), oversamplingBitNb)
               + shift_left(resize(c, u'length), 2*oversamplingBitNb);
          v <=   resize(6*a, v'length)
               + shift_left(resize(2*b, v'length), oversamplingBitNb);
          w <=   resize(6*a, w'length);
          sampleOut <= resize(d, sampleOut'length);
        else
          x <= x + u;
          u <= u + v;
          v <= v + w;
          sampleOut <= resize(
            shift_right(x, 3*oversamplingBitNb+1), sampleOut'length
          );
                                                               -- limit overflow
          if x(x'high downto x'high-additionalBitNb) = "01" then
            sampleOut <= not shift_left(
              resize("10", sampleOut'length), sampleOut'length-2
            );
          end if;
                                                              -- limit underflow
          if x(x'high downto x'high-additionalBitNb) = "10" then
            sampleOut <= shift_left(
              resize("10", sampleOut'length), sampleOut'length-2
            );
          end if;
        end if;
      end if;
    end if;
  end process iterativePolynom;

END ARCHITECTURE masterVersion;




-- VHDL Entity SystemOnChip.sinCosTable.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:20 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY sinCosTable IS
    GENERIC( 
        inputBitNb        : positive := 16;
        outputBitNb       : positive := 16;
        tableAddressBitNb : positive := 3
    );
    PORT( 
        sine   : OUT    signed (outputBitNb-1 DOWNTO 0);
        phase  : IN     unsigned (inputBitNb-1 DOWNTO 0);
        cosine : OUT    signed (outputBitNb-1 DOWNTO 0)
    );

-- Declarations

END sinCosTable ;





ARCHITECTURE masterVersion OF sinCosTable IS

  signal changeSignSine : std_uLogic;
  signal changeSignCosine : std_uLogic;
  signal flipPhase : std_uLogic;
  signal phaseTableAddress1 : unsigned(tableAddressBitNb-1 downto 0);
  signal phaseTableAddress2 : unsigned(phaseTableAddress1'range);
  signal quarterSine : signed(sine'range);
  signal quarterCosine : signed(cosine'range);

BEGIN

  changeSignSine <= phase(phase'high);
  changeSignCosine <= phase(phase'high) xor phase(phase'high-1);
  flipPhase <= phase(phase'high-1);

  phaseTableAddress1 <= phase(phase'high-2 downto phase'high-2-tableAddressBitNb+1);

  checkPhase: process(flipPhase, phaseTableAddress1)
  begin
    if flipPhase = '0' then
      phaseTableAddress2 <= phaseTableAddress1;
    else
      phaseTableAddress2 <= 0 - phaseTableAddress1;
    end if;
  end process checkPhase;


  quarterTableSine: process(phaseTableAddress2, flipPhase)
  begin
    case to_integer(phaseTableAddress2) is
      when 0 => if flipPhase = '0' then
                  quarterSine <= to_signed(16#0000#, quarterSine'length);
                else
                  quarterSine <= to_signed(16#7FFF#, quarterSine'length);
                end if;
      when 1 => quarterSine <= to_signed(16#18F9#, quarterSine'length);
      when 2 => quarterSine <= to_signed(16#30FB#, quarterSine'length);
      when 3 => quarterSine <= to_signed(16#471C#, quarterSine'length);
      when 4 => quarterSine <= to_signed(16#5A82#, quarterSine'length);
      when 5 => quarterSine <= to_signed(16#6A6D#, quarterSine'length);
      when 6 => quarterSine <= to_signed(16#7641#, quarterSine'length);
      when 7 => quarterSine <= to_signed(16#7D89#, quarterSine'length);
      when others => quarterSine <= (others => '-');
    end case;
  end process quarterTableSine;


  quarterTableCosine: process(phaseTableAddress2, flipPhase)
  begin
    case to_integer(phaseTableAddress2) is
      when 0 => if flipPhase = '1' then
                  quarterCosine <= to_signed(16#0000#, quarterSine'length);
                else
                  quarterCosine <= to_signed(16#7FFF#, quarterSine'length);
                end if;
      when 7 => quarterCosine <= to_signed(16#18F9#, quarterSine'length);
      when 6 => quarterCosine <= to_signed(16#30FB#, quarterSine'length);
      when 5 => quarterCosine <= to_signed(16#471C#, quarterSine'length);
      when 4 => quarterCosine <= to_signed(16#5A82#, quarterSine'length);
      when 3 => quarterCosine <= to_signed(16#6A6D#, quarterSine'length);
      when 2 => quarterCosine <= to_signed(16#7641#, quarterSine'length);
      when 1 => quarterCosine <= to_signed(16#7D89#, quarterSine'length);
      when others => quarterCosine <= (others => '-');
    end case;
  end process quarterTableCosine;


  checkSignSine: process(changeSignSine, quarterSine)
  begin
    if changeSignSine = '0' then
      sine <= quarterSine;
    else
      sine <= 0 - quarterSine;
    end if;
  end process checkSignSine;


  checkSignCosine: process(changeSignCosine, quarterCosine)
  begin
    if changeSignCosine = '0' then
      cosine <= quarterCosine;
    else
      cosine <= 0 - quarterCosine;
    end if;
  end process checkSignCosine;

END ARCHITECTURE masterVersion;




-- VHDL Entity SystemOnChip.periphSpeedController.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:20 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY periphSpeedController IS
    GENERIC( 
        updatePeriodBitNb : positive := 16
    );
    PORT( 
        enableOut    : OUT    std_ulogic;
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        updatePeriod : IN     unsigned (updatePeriodBitNb-1 DOWNTO 0);
        enableIn     : IN     std_ulogic
    );

-- Declarations

END periphSpeedController ;





ARCHITECTURE masterVersion OF periphSpeedController IS

  signal enableCounter: unsigned(updatePeriod'range);
  signal endOfCount: std_uLogic;

BEGIN

  count: process(reset, clock)
  begin
    if reset = '1' then
      enableCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (endOfCount = '0') and (enableIn = '1') then
        enableCounter <= enableCounter - 1;
      else
        enableCounter <= updatePeriod;
      end if;
    end if;
  end process count;

  testEndOfCount: process(enableCounter)
  begin
    if enableCounter = 0 then
      endOfCount <= '1';
    else
      endOfCount <= '0';
    end if;
  end process testEndOfCount;

  enableOut <= endOfCount and enableIn;

END ARCHITECTURE masterVersion;





-- VHDL Entity SplineInterpolator.interpolatorShiftRegister.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:00:24 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY interpolatorShiftRegister IS
    GENERIC( 
        signalBitNb : positive := 16
    );
    PORT( 
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        shiftSamples : IN     std_ulogic;
        sampleIn     : IN     signed (signalBitNb-1 DOWNTO 0);
        sample1      : OUT    signed (signalBitNb-1 DOWNTO 0);
        sample2      : OUT    signed (signalBitNb-1 DOWNTO 0);
        sample3      : OUT    signed (signalBitNb-1 DOWNTO 0);
        sample4      : OUT    signed (signalBitNb-1 DOWNTO 0)
    );

-- Declarations

END interpolatorShiftRegister ;





ARCHITECTURE masterVersion OF interpolatorShiftRegister IS

  signal sample4_int: signed(sampleIn'range);
  signal sample3_int: signed(sampleIn'range);
  signal sample2_int: signed(sampleIn'range);
  signal sample1_int: signed(sampleIn'range);

begin

  shiftThem: process(reset, clock)
  begin
    if reset = '1' then
      sample1_int <= (others => '0');
      sample2_int <= (others => '0');
      sample3_int <= (others => '0');
      sample4_int <= (others => '0');
    elsif rising_edge(clock) then
      if shiftSamples = '1' then
        sample1_int <= sample2_int;
        sample2_int <= sample3_int;
        sample3_int <= sample4_int;
        sample4_int <= sampleIn;
      end if;
    end if;
  end process shiftThem;

  sample4 <= sample4_int;
  sample3 <= sample3_int;
  sample2 <= sample2_int;
  sample1 <= sample1_int;

END ARCHITECTURE masterVersion;




-- VHDL Entity SplineInterpolator.interpolatorTrigger.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:00:28 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY interpolatorTrigger IS
    GENERIC( 
        counterBitNb : positive := 4
    );
    PORT( 
        triggerOut : OUT    std_ulogic;
        clock      : IN     std_ulogic;
        reset      : IN     std_ulogic;
        en         : IN     std_ulogic
    );

-- Declarations

END interpolatorTrigger ;





ARCHITECTURE masterVersion OF interpolatorTrigger IS

  signal triggerCounter: unsigned(counterBitNb-1 downto 0);

BEGIN

  count: process(reset, clock)
  begin
    if reset = '1' then
      triggerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if en = '1' then
        triggerCounter <= triggerCounter + 1;
      end if;
    end if;
  end process count;

  trig: process(triggerCounter, en)
  begin
    if triggerCounter = 0 then
      triggerOut <= en;
    else
      triggerOut <= '0';
    end if;
  end process trig;

END ARCHITECTURE masterVersion;




--
-- VHDL Architecture SystemOnChip.ahbBeamerOperator.struct
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:23 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;

-- LIBRARY DigitalToAnalogConverter;
-- LIBRARY SplineInterpolator;
-- LIBRARY SystemOnChip;
-- LIBRARY WaveformGenerator;

ARCHITECTURE struct OF ahbBeamerOperator IS

    -- Architecture declarations
    constant coeffBitNb : positive := signalBitNb+3+1;
    constant sampleCountBitNb : positive := 8;
    constant patternAddressBitNb : positive := 8;
    -- sinewave generator
    constant tableAddressBitNb : positive := 3;
    constant phaseBitNb : positive := sampleCountBitNb + tableAddressBitNb + 2;

    -- Internal signal declarations
    SIGNAL aX                  : signed(coeffBitNb-1 DOWNTO 0);
    SIGNAL aY                  : signed(coeffBitNb-1 DOWNTO 0);
    SIGNAL bX                  : signed(coeffBitNb-1 DOWNTO 0);
    SIGNAL bY                  : signed(coeffBitNb-1 DOWNTO 0);
    SIGNAL cX                  : signed(coeffBitNb-1 DOWNTO 0);
    SIGNAL cY                  : signed(coeffBitNb-1 DOWNTO 0);
    SIGNAL cosine              : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL dX                  : signed(coeffBitNb-1 DOWNTO 0);
    SIGNAL dY                  : signed(coeffBitNb-1 DOWNTO 0);
    SIGNAL interpolateLinear   : std_ulogic;
    SIGNAL interpolationEn     : std_ulogic;
    SIGNAL interpolationEnable : std_ulogic;
    SIGNAL phase               : unsigned(phaseBitNb-1 DOWNTO 0);
    SIGNAL sampleX             : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL sampleX1            : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL sampleX2            : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL sampleX3            : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL sampleX4            : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL sampleY             : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL sampleY1            : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL sampleY2            : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL sampleY3            : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL sampleY4            : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL samplesX            : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL samplesY            : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL sine                : signed(signalBitNb-1 DOWNTO 0);
    SIGNAL step                : unsigned(phaseBitNb-1 DOWNTO 0);
    SIGNAL unsignedX           : unsigned(signalBitNb-1 DOWNTO 0);
    SIGNAL unsignedY           : unsigned(signalBitNb-1 DOWNTO 0);

    -- Implicit buffer signal declarations
    SIGNAL newPolynom_internal : std_ulogic;


    -- Component Declarations
    COMPONENT DAC
    GENERIC (
        signalBitNb : positive := 16
    );
    PORT (
        serialOut  : OUT    std_ulogic ;
        parallelIn : IN     unsigned (signalBitNb-1 DOWNTO 0);
        clock      : IN     std_ulogic ;
        reset      : IN     std_ulogic 
    );
    END COMPONENT;
    COMPONENT interpolatorCalculatePolynom
    GENERIC (
        signalBitNb       : positive := 16;
        coeffBitNb        : positive := 16;
        oversamplingBitNb : positive := 8
    );
    PORT (
        clock          : IN     std_ulogic ;
        reset          : IN     std_ulogic ;
        restartPolynom : IN     std_ulogic ;
        d              : IN     signed (coeffBitNb-1 DOWNTO 0);
        sampleOut      : OUT    signed (signalBitNb-1 DOWNTO 0);
        c              : IN     signed (coeffBitNb-1 DOWNTO 0);
        b              : IN     signed (coeffBitNb-1 DOWNTO 0);
        a              : IN     signed (coeffBitNb-1 DOWNTO 0);
        en             : IN     std_ulogic 
    );
    END COMPONENT;
    COMPONENT interpolatorCoefficients
    GENERIC (
        bitNb      : positive := 16;
        coeffBitNb : positive := 16
    );
    PORT (
        sample1           : IN     signed (bitNb-1 DOWNTO 0);
        sample2           : IN     signed (bitNb-1 DOWNTO 0);
        sample3           : IN     signed (bitNb-1 DOWNTO 0);
        sample4           : IN     signed (bitNb-1 DOWNTO 0);
        a                 : OUT    signed (coeffBitNb-1 DOWNTO 0);
        b                 : OUT    signed (coeffBitNb-1 DOWNTO 0);
        c                 : OUT    signed (coeffBitNb-1 DOWNTO 0);
        d                 : OUT    signed (coeffBitNb-1 DOWNTO 0);
        interpolateLinear : IN     std_ulogic 
    );
    END COMPONENT;
    COMPONENT interpolatorShiftRegister
    GENERIC (
        signalBitNb : positive := 16
    );
    PORT (
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        shiftSamples : IN     std_ulogic ;
        sampleIn     : IN     signed (signalBitNb-1 DOWNTO 0);
        sample1      : OUT    signed (signalBitNb-1 DOWNTO 0);
        sample2      : OUT    signed (signalBitNb-1 DOWNTO 0);
        sample3      : OUT    signed (signalBitNb-1 DOWNTO 0);
        sample4      : OUT    signed (signalBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT interpolatorTrigger
    GENERIC (
        counterBitNb : positive := 4
    );
    PORT (
        triggerOut : OUT    std_ulogic ;
        clock      : IN     std_ulogic ;
        reset      : IN     std_ulogic ;
        en         : IN     std_ulogic 
    );
    END COMPONENT;
    COMPONENT offsetToUnsigned
    GENERIC (
        bitNb : positive := 16
    );
    PORT (
        unsignedOut : OUT    unsigned (bitNb-1 DOWNTO 0);
        signedIn    : IN     signed (bitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT periphSpeedController
    GENERIC (
        updatePeriodBitNb : positive := 16
    );
    PORT (
        enableOut    : OUT    std_ulogic ;
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        updatePeriod : IN     unsigned (updatePeriodBitNb-1 DOWNTO 0);
        enableIn     : IN     std_ulogic 
    );
    END COMPONENT;
    COMPONENT sinCosTable
    GENERIC (
        inputBitNb        : positive := 16;
        outputBitNb       : positive := 16;
        tableAddressBitNb : positive := 3
    );
    PORT (
        sine   : OUT    signed (outputBitNb-1 DOWNTO 0);
        phase  : IN     unsigned (inputBitNb-1 DOWNTO 0);
        cosine : OUT    signed (outputBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT sawtoothGen
    GENERIC (
        bitNb : positive := 16
    );
    PORT (
        sawtooth : OUT    unsigned (bitNb-1 DOWNTO 0);
        clock    : IN     std_ulogic ;
        reset    : IN     std_ulogic ;
        step     : IN     unsigned (bitNb-1 DOWNTO 0);
        en       : IN     std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : DAC USE ENTITY DigitalToAnalogConverter.DAC;
--     FOR ALL : interpolatorCalculatePolynom USE ENTITY SplineInterpolator.interpolatorCalculatePolynom;
--     FOR ALL : interpolatorCoefficients USE ENTITY SplineInterpolator.interpolatorCoefficients;
--     FOR ALL : interpolatorShiftRegister USE ENTITY SplineInterpolator.interpolatorShiftRegister;
--     FOR ALL : interpolatorTrigger USE ENTITY SplineInterpolator.interpolatorTrigger;
--     FOR ALL : offsetToUnsigned USE ENTITY SplineInterpolator.offsetToUnsigned;
--     FOR ALL : periphSpeedController USE ENTITY SystemOnChip.periphSpeedController;
--     FOR ALL : sawtoothGen USE ENTITY WaveformGenerator.sawtoothGen;
--     FOR ALL : sinCosTable USE ENTITY SystemOnChip.sinCosTable;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    samplesY <= sine when selSinCos = '1'
      else signed(memY);

    -- HDL Embedded Text Block 2 eb2
    samplesX <= cosine when selSinCos = '1'
      else signed(memX);

    -- HDL Embedded Text Block 4 eb4
    step <= to_unsigned(1, step'length);

    -- HDL Embedded Text Block 5 eb5
    interpolationEnable <= '1' when selSinCos = '1'
      else interpolationEn;
    interpolateLinear <= '0' when selSinCos = '1'
      else interpolateLin;
    --interpolateLinear <= interpolateLin;


    -- Instance port mappings.
    I_dacx : DAC
        GENERIC MAP (
            signalBitNb => signalBitNb
        )
        PORT MAP (
            serialOut  => outX,
            parallelIn => unsignedX,
            clock      => clock,
            reset      => reset
        );
    I_dacy : DAC
        GENERIC MAP (
            signalBitNb => signalBitNb
        )
        PORT MAP (
            serialOut  => outY,
            parallelIn => unsignedY,
            clock      => clock,
            reset      => reset
        );
    I_polyx : interpolatorCalculatePolynom
        GENERIC MAP (
            signalBitNb       => signalBitNb,
            coeffBitNb        => coeffBitNb,
            oversamplingBitNb => sampleCountBitNb
        )
        PORT MAP (
            clock          => clock,
            reset          => reset,
            restartPolynom => newPolynom_internal,
            d              => dX,
            sampleOut      => sampleX,
            c              => cX,
            b              => bX,
            a              => aX,
            en             => interpolationEnable
        );
    I_polyy : interpolatorCalculatePolynom
        GENERIC MAP (
            signalBitNb       => signalBitNb,
            coeffBitNb        => coeffBitNb,
            oversamplingBitNb => sampleCountBitNb
        )
        PORT MAP (
            clock          => clock,
            reset          => reset,
            restartPolynom => newPolynom_internal,
            d              => dY,
            sampleOut      => sampleY,
            c              => cY,
            b              => bY,
            a              => aY,
            en             => interpolationEnable
        );
    I_coeffx : interpolatorCoefficients
        GENERIC MAP (
            bitNb      => signalBitNb,
            coeffBitNb => coeffBitNb
        )
        PORT MAP (
            sample1           => sampleX1,
            sample2           => sampleX2,
            sample3           => sampleX3,
            sample4           => sampleX4,
            a                 => aX,
            b                 => bX,
            c                 => cX,
            d                 => dX,
            interpolateLinear => interpolateLinear
        );
    I_coeffy : interpolatorCoefficients
        GENERIC MAP (
            bitNb      => signalBitNb,
            coeffBitNb => coeffBitNb
        )
        PORT MAP (
            sample1           => sampleY1,
            sample2           => sampleY2,
            sample3           => sampleY3,
            sample4           => sampleY4,
            a                 => aY,
            b                 => bY,
            c                 => cY,
            d                 => dY,
            interpolateLinear => interpolateLinear
        );
    I_srx : interpolatorShiftRegister
        GENERIC MAP (
            signalBitNb => signalBitNb
        )
        PORT MAP (
            clock        => clock,
            reset        => reset,
            shiftSamples => newPolynom_internal,
            sampleIn     => samplesX,
            sample1      => sampleX1,
            sample2      => sampleX2,
            sample3      => sampleX3,
            sample4      => sampleX4
        );
    I_sry : interpolatorShiftRegister
        GENERIC MAP (
            signalBitNb => signalBitNb
        )
        PORT MAP (
            clock        => clock,
            reset        => reset,
            shiftSamples => newPolynom_internal,
            sampleIn     => samplesY,
            sample1      => sampleY1,
            sample2      => sampleY2,
            sample3      => sampleY3,
            sample4      => sampleY4
        );
    I_trig : interpolatorTrigger
        GENERIC MAP (
            counterBitNb => sampleCountBitNb
        )
        PORT MAP (
            triggerOut => newPolynom_internal,
            clock      => clock,
            reset      => reset,
            en         => interpolationEnable
        );
    I_offsx : offsetToUnsigned
        GENERIC MAP (
            bitNb => signalBitNb
        )
        PORT MAP (
            unsignedOut => unsignedX,
            signedIn    => sampleX
        );
    I_offsy : offsetToUnsigned
        GENERIC MAP (
            bitNb => signalBitNb
        )
        PORT MAP (
            unsignedOut => unsignedY,
            signedIn    => sampleY
        );
    I_speed : periphSpeedController
        GENERIC MAP (
            updatePeriodBitNb => updatePeriodBitNb
        )
        PORT MAP (
            enableOut    => interpolationEn,
            clock        => clock,
            reset        => reset,
            updatePeriod => updatePeriod,
            enableIn     => run
        );
    I_sin : sinCosTable
        GENERIC MAP (
            inputBitNb        => phaseBitNb,
            outputBitNb       => signalBitNb,
            tableAddressBitNb => tableAddressBitNb
        )
        PORT MAP (
            sine   => sine,
            phase  => phase,
            cosine => cosine
        );
    I_phase : sawtoothGen
        GENERIC MAP (
            bitNb => phaseBitNb
        )
        PORT MAP (
            sawtooth => phase,
            clock    => clock,
            reset    => reset,
            step     => step,
            en       => interpolationEnable
        );

    -- Implicit buffered output assignments
    newPolynom <= newPolynom_internal;

END struct;




-- VHDL Entity SystemOnChip.ahbBeamerRegisters.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:21 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY AhbLite;
  use work.ahbLite.all;

ENTITY ahbBeamerRegisters IS
    GENERIC( 
        updatePeriodBitNb   : positive := 16;
        signalBitNb         : positive := 16;
        patternAddressBitNb : positive := 8;
        testOutBitNb        : positive := 16
    );
    PORT( 
        testOut        : OUT    std_ulogic_vector (1 TO testOutBitNb);
        memX           : OUT    std_ulogic_vector (signalBitNb-1 DOWNTO 0);
        memY           : OUT    std_ulogic_vector (signalBitNb-1 DOWNTO 0);
        run            : OUT    std_ulogic;
        updatePeriod   : OUT    unsigned (updatePeriodBitNb-1 DOWNTO 0);
        interpolateLin : OUT    std_ulogic;
        newPolynom     : IN     std_ulogic;
        hClk           : IN     std_ulogic;
        hRData         : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hAddr          : IN     unsigned (ahbAddressBitNb-1 DOWNTO 0);
        hReset_n       : IN     std_ulogic;
        hWData         : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hTrans         : IN     std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWrite         : IN     std_ulogic;
        hSel           : IN     std_ulogic;
        hReady         : OUT    std_ulogic;
        hResp          : OUT    std_ulogic
    );

-- Declarations

END ahbBeamerRegisters ;





-- VHDL Entity SystemOnChip.blockRAMAddressCounter.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:20 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY blockRAMAddressCounter IS
    GENERIC( 
        addressBitNb : positive := 8
    );
    PORT( 
        en          : IN     std_ulogic;
        clock       : IN     std_ulogic;
        reset       : IN     std_ulogic;
        updateMem   : IN     std_ulogic;
        addr        : OUT    unsigned (addressBitNb-1 DOWNTO 0);
        patternSize : IN     unsigned (addressBitNb-1 DOWNTO 0)
    );

-- Declarations

END blockRAMAddressCounter ;





ARCHITECTURE masterVersion OF blockRAMAddressCounter IS

  signal updateMemDelayed : std_ulogic;
  signal updateMemChanging : std_ulogic;
  signal addressInt : unsigned(addr'range);

BEGIN

  delay: process(reset, clock)
  begin
    if reset = '1' then
      updateMemDelayed <= '0';
    elsif rising_edge(clock) then
      updateMemDelayed <= updateMem;
    end if;
  end process delay;

  updateMemChanging <= '1' when (updateMem /= updateMemDelayed)
    else '0';

  count: process(reset, clock)
  begin
    if reset = '1' then
      addressInt <= (others => '0');
    elsif rising_edge(clock) then
      if updateMemChanging = '1' then
        addressInt <= (others => '0');
      elsif en = '1' then
        if updateMem = '1' then
          addressInt <= addressInt + 1;
        else
          if addressInt < patternSize - 1  then
            addressInt <= addressInt + 1;
          else
            addressInt <= (others => '0');
          end if;
        end if;
      end if;
    end if;
  end process count;

  addr <= addressInt;

END ARCHITECTURE masterVersion;





-- VHDL Entity SystemOnChip.periphControlReg.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:20 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY periphControlReg IS
    GENERIC( 
        dataBitNb        : positive := 16;
        patternSizeBitNb : positive := 8
    );
    PORT( 
        run               : OUT    std_ulogic;
        dataIn            : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        updatePattern     : OUT    std_ulogic;
        dataOut           : OUT    std_logic_vector (dataBitNb-1 DOWNTO 0);
        write             : IN     std_ulogic;
        en                : IN     std_ulogic;
        clock             : IN     std_ulogic;
        reset             : IN     std_ulogic;
        interpolateLinear : OUT    std_ulogic;
        patternSize       : OUT    unsigned (patternSizeBitNb-1 DOWNTO 0)
    );

-- Declarations

END periphControlReg ;





ARCHITECTURE masterVersion OF periphControlReg IS

  constant      runId                   : natural       := 0;
  constant      updatePatternId         : natural       := 1;
  constant      interpolateLinearId     : natural       := 2;
  constant      patternSizeHighId       : natural       := 15;

  signal        runInt                  : std_ulogic;
  signal        updatePatternInt        : std_ulogic;
  signal        interpolateLinearInt    : std_ulogic;
  signal        patternSizeInt          : std_ulogic_vector(patternSize'range);

  signal        dataOutReg      : std_ulogic_vector(dataOut'range);

BEGIN

  store: process(reset, clock)
  begin
    if reset = '1' then
      runInt               <= '0';
      updatePatternInt     <= '0';
      interpolateLinearInt <= '0';
      patternSizeInt       <= (others => '0');
    elsif rising_edge(clock) then
      if (en = '1') and (write = '1') then
        runInt               <= dataIn(runId);
        updatePatternInt     <= dataIn(updatePatternId);
        interpolateLinearInt <= dataIn(interpolateLinearId);
        patternSizeInt       <=
          dataIn(patternSizeHighId downto patternSizeHighId-patternSize'length+1);
      end if;
    end if;
  end process store;

  run               <= runInt;
  updatePattern     <= updatePatternInt;
  interpolateLinear <= interpolateLinearInt;
  patternSize       <= unsigned(patternSizeInt);

  process(runInt, updatePatternInt, interpolateLinearInt, patternSizeInt)
  begin
    dataOutReg                      <= (others => '-');
    dataOutReg(runId)               <= runInt;
    dataOutReg(updatePatternId)     <= updatePatternInt;
    dataOutReg(interpolateLinearId) <= interpolateLinearInt;
    dataOutReg(patternSizeHighId downto patternSizeHighId-patternSize'length+1)
      <= patternSizeInt;
  end process;

  dataOut <= std_logic_vector(dataOutReg) when en = '1'
    else (others => 'Z');

END ARCHITECTURE masterVersion;




-- VHDL Entity SystemOnChip.blockRAMControl.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:20 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY blockRAMControl IS
    PORT( 
        memWr     : OUT    std_ulogic;
        sel       : IN     std_ulogic;
        memEn     : OUT    std_ulogic;
        update    : IN     std_ulogic;
        wr        : IN     std_ulogic;
        cntIncr   : OUT    std_ulogic;
        newSample : IN     std_ulogic;
        clock     : IN     std_ulogic;
        reset     : IN     std_ulogic
    );

-- Declarations

END blockRAMControl ;





ARCHITECTURE masterVersion OF blockRAMControl IS

  signal writeDelayed: std_ulogic;
  signal writePulse: std_ulogic;
  signal memWr1: std_ulogic;

BEGIN

  delayWrPulse: process(reset, clock)
  begin
    if reset = '1' then
      writeDelayed <= '0';
    elsif rising_edge(clock) then
      writeDelayed <= wr;
    end if;
  end process delayWrPulse;

  writePulse <= '1' when (wr='1') and (writeDelayed='0')
    else '0';

  cntIncr <= '1' when ( (update = '0') and (newSample = '1') )
                   or ( (update = '1') and (writePulse = '1') and (sel = '1') )
    else '0';

  memWr1 <= '1' when (update = '1') and (writePulse = '1') and (sel = '1')
    else '0';

--  delayMemWrPulse: process(reset, clock)
--  begin
--    if reset = '1' then
--      memWr <= '0';
--    elsif rising_edge(clock) then
--      memWr <= memWr1;
--    end if;
--  end process delayMemWrPulse;
  memWr <= memWr1;

  memEn <= '1' when (sel = '1') or (update = '0')
    else '0';

END ARCHITECTURE masterVersion;





-- VHDL Entity SystemOnChip.periphAddressDecoder.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:20 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY periphAddressDecoder IS
    GENERIC( 
        addressBitNb : positive := 24
    );
    PORT( 
        selControl : OUT    std_ulogic;
        addr       : IN     unsigned (addressBitNb-1 DOWNTO 0);
        selSpeed   : OUT    std_ulogic;
        selX       : OUT    std_ulogic;
        selY       : OUT    std_ulogic;
        selZ       : OUT    std_ulogic
    );

-- Declarations

END periphAddressDecoder ;





ARCHITECTURE masterVersion OF periphAddressDecoder IS
BEGIN

  decode: process(addr)
  begin
    selControl  <= '0';
    selSpeed    <= '0';
    selX        <= '0';
    selY        <= '0';
    selZ        <= '0';
    case to_integer(addr(3 downto 0)) is
      when 16#00# => selControl <= '1';
      when 16#01# => selSpeed <= '1';
      when 16#02# => selX <= '1';
      when 16#03# => selY <= '1';
      when 16#04# => selZ <= '1';
      when others => null;
    end case;
  end process decode;

END ARCHITECTURE masterVersion;





-- VHDL Entity SystemOnChip.blockRAM.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:20 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY blockRAM IS
    GENERIC( 
        addressBitNb : positive := 8;
        dataBitNb    : positive := 16;
        initFileSpec : string   := "ramInit.txt"
    );
    PORT( 
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        en      : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        write   : IN     std_ulogic;
        addr    : IN     unsigned (addressBitNb-1 DOWNTO 0)
    );

-- Declarations

END blockRAM ;





USE std.textio.all;

ARCHITECTURE Spartan3E OF blockRAM IS

  subtype registerType is std_ulogic_vector(dataBitNb-1 downto 0);
  type memoryType is array (0 to 2**addressBitNb-1) of registerType;

  -- Define function to create initvalue signal
  impure function ReadRamContentFromFile(ramContentFileSpec : in string) return memoryType is
    FILE     ramContentFile     : text open read_mode is ramContentFileSpec;
    variable ramContentFileLine : line;
    variable ramContent         : memoryType;
    variable ramCurrentWord     : bit_vector(registerType'range);
    variable index              : natural := 0; --241;
  begin
--    for index in ramContent'range loop
    while not endfile(ramContentFile) loop
      readline(ramContentFile, ramContentFileLine);
      read(ramContentFileLine, ramCurrentWord);
      ramContent(index) := std_ulogic_vector(to_stdlogicvector(ramCurrentWord));
      index := index + 1;
    end loop;
    return ramContent;
  end function;

  shared variable memoryArray: memoryType := ReadRamContentFromFile(initFileSpec);

BEGIN

  portA: process(clock)
  begin
    if rising_edge(clock) then
      if (en = '1') then
        if (write = '1') then
          memoryArray(to_integer(addr)) := dataIn;
          dataOut <= dataIn;
        else
          dataOut <= memoryArray(to_integer(addr));
        end if;
      end if;
    end if;
  end process portA;

END ARCHITECTURE Spartan3E;




-- VHDL Entity SystemOnChip.periphSpeedReg.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:20 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY periphSpeedReg IS
    GENERIC( 
        dataBitNb         : positive := 16;
        updatePeriodBitNb : positive := 16
    );
    PORT( 
        updatePeriod : OUT    unsigned (updatePeriodBitNb-1 DOWNTO 0);
        dataIn       : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOut      : OUT    std_logic_vector (dataBitNb-1 DOWNTO 0);
        en           : IN     std_ulogic;
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        write        : IN     std_ulogic
    );

-- Declarations

END periphSpeedReg ;





ARCHITECTURE masterVersion OF periphSpeedReg IS

  signal updatePeriodInt: unsigned(updatePeriod'range);

BEGIN

  store: process(reset, clock)
  begin
    if reset = '1' then
      updatePeriodInt <= (others => '0');
    elsif rising_edge(clock) then
      if en = '1' then
        if write = '1' then
          updatePeriodInt <= unsigned(dataIn(updatePeriodInt'range));
        end if;
      end if;
    end if;
  end process store;

  updatePeriod <= updatePeriodInt;

  writeBack: process(en, updatePeriodInt)
  begin
    if en = '1' then
      dataOut <= (others => '-');
      dataOut(updatePeriodInt'range) <= std_logic_vector(updatePeriodInt);
    else
      dataOut <= (others => 'Z');
    end if;
  end process writeBack;

END ARCHITECTURE masterVersion;




--
-- VHDL Architecture SystemOnChip.ahbBeamerRegisters.struct
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:23 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;

-- LIBRARY SystemOnChip;

ARCHITECTURE struct OF ahbBeamerRegisters IS

    -- Architecture declarations
    constant addressBitNb: positive := hAddr'length;
    constant dataBitNb : positive := hWData'length;

    -- Internal signal declarations
    SIGNAL clock              : std_ulogic;
    SIGNAL reset              : std_ulogic;
    SIGNAL addr               : unsigned(addressBitNb-1 DOWNTO 0);
    SIGNAL addrX              : unsigned(patternAddressBitNb-1 DOWNTO 0);
    SIGNAL addrY              : unsigned(patternAddressBitNb-1 DOWNTO 0);
    SIGNAL cntIncrX           : std_ulogic;
    SIGNAL cntIncrY           : std_ulogic;
    SIGNAL dataIn             : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL dataOut            : std_logic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL memEnX             : std_ulogic;
    SIGNAL memEnY             : std_ulogic;
    SIGNAL memWrX             : std_ulogic;
    SIGNAL memWrY             : std_ulogic;
    SIGNAL patternSize        : unsigned(patternAddressBitNb-1 DOWNTO 0);
    SIGNAL selControl         : std_ulogic;
    SIGNAL selSpeed           : std_ulogic;
    SIGNAL selX               : std_ulogic;
    SIGNAL selY               : std_ulogic;
    SIGNAL updatePattern      : std_ulogic;
    SIGNAL write              : std_ulogic;
    SIGNAL memDataIn          : std_ulogic_vector(signalBitNb-1 DOWNTO 0);
    SIGNAL run_int            : std_ulogic;
    SIGNAL interpolateLin_int : std_ulogic;


    -- Component Declarations
    COMPONENT blockRAM
    GENERIC (
        addressBitNb : positive := 8;
        dataBitNb    : positive := 16;
        initFileSpec : string   := "ramInit.txt"
    );
    PORT (
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        en      : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        write   : IN     std_ulogic ;
        addr    : IN     unsigned (addressBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT blockRAMAddressCounter
    GENERIC (
        addressBitNb : positive := 8
    );
    PORT (
        en          : IN     std_ulogic ;
        clock       : IN     std_ulogic ;
        reset       : IN     std_ulogic ;
        updateMem   : IN     std_ulogic ;
        addr        : OUT    unsigned (addressBitNb-1 DOWNTO 0);
        patternSize : IN     unsigned (addressBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT blockRAMControl
    PORT (
        memWr     : OUT    std_ulogic ;
        sel       : IN     std_ulogic ;
        memEn     : OUT    std_ulogic ;
        update    : IN     std_ulogic ;
        wr        : IN     std_ulogic ;
        cntIncr   : OUT    std_ulogic ;
        newSample : IN     std_ulogic ;
        clock     : IN     std_ulogic ;
        reset     : IN     std_ulogic 
    );
    END COMPONENT;
    COMPONENT periphAddressDecoder
    GENERIC (
        addressBitNb : positive := 24
    );
    PORT (
        selControl : OUT    std_ulogic ;
        addr       : IN     unsigned (addressBitNb-1 DOWNTO 0);
        selSpeed   : OUT    std_ulogic ;
        selX       : OUT    std_ulogic ;
        selY       : OUT    std_ulogic ;
        selZ       : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT periphControlReg
    GENERIC (
        dataBitNb        : positive := 16;
        patternSizeBitNb : positive := 8
    );
    PORT (
        run               : OUT    std_ulogic ;
        dataIn            : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        updatePattern     : OUT    std_ulogic ;
        dataOut           : OUT    std_logic_vector (dataBitNb-1 DOWNTO 0);
        write             : IN     std_ulogic ;
        en                : IN     std_ulogic ;
        clock             : IN     std_ulogic ;
        reset             : IN     std_ulogic ;
        interpolateLinear : OUT    std_ulogic ;
        patternSize       : OUT    unsigned (patternSizeBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT periphSpeedReg
    GENERIC (
        dataBitNb         : positive := 16;
        updatePeriodBitNb : positive := 16
    );
    PORT (
        updatePeriod : OUT    unsigned (updatePeriodBitNb-1 DOWNTO 0);
        dataIn       : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOut      : OUT    std_logic_vector (dataBitNb-1 DOWNTO 0);
        en           : IN     std_ulogic ;
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        write        : IN     std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : blockRAM USE ENTITY SystemOnChip.blockRAM;
--     FOR ALL : blockRAMAddressCounter USE ENTITY SystemOnChip.blockRAMAddressCounter;
--     FOR ALL : blockRAMControl USE ENTITY SystemOnChip.blockRAMControl;
--     FOR ALL : periphAddressDecoder USE ENTITY SystemOnChip.periphAddressDecoder;
--     FOR ALL : periphControlReg USE ENTITY SystemOnChip.periphControlReg;
--     FOR ALL : periphSpeedReg USE ENTITY SystemOnChip.periphSpeedReg;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 3 eb3
    testout( 1) <= run_int; run <= run_int;
    testout( 2) <= updatePattern;
    testout( 3) <= interpolateLin_int; interpolateLin <= interpolateLin_int;
    testout( 4) <= newPolynom;
    testout( 5) <= newPolynom;
    testout( 6) <= '0';
    testout( 7) <= '0';
    testout( 8) <= selControl;
    testout( 9) <= selSpeed;
    testout(10) <= selX;
    testout(11) <= selY;
    testout(12) <= '0';
    testout(13) <= addr(0);
    testout(14) <= addr(1);
    testout(15) <= dataIn(0);
    testout(16) <= dataIn(1);

    -- HDL Embedded Text Block 8 eb8
    storeControls: process(reset, clock)
    begin
      if reset = '1' then
        addr <= (others => '0');
        write <= '0';
      elsif rising_edge(clock) then
        write <= '0';
        if (hSel = '1') and (hTrans = transNonSeq) then
          addr <= hAddr(addr'range);
          write <= hWrite;
        end if;
      end if;
    end process storeControls;
    
    dataIn <= hWData;

    -- HDL Embedded Text Block 9 eb9
    memDataIn <= dataIn(memDataIn'range);

    -- HDL Embedded Text Block 10 eb10
    hRData <= std_ulogic_vector(dataOut);
    
    hReady <= '1';  -- no wait state
    hResp  <= '0';  -- data OK

    -- HDL Embedded Text Block 11 eb11
    clock<= hClk;
    
    reset <= not hReset_n;


    -- Instance port mappings.
    I_ramx : blockRAM
        GENERIC MAP (
            addressBitNb => patternAddressBitNb,
            dataBitNb    => signalBitNb,
            initFileSpec => "C:/work/repo/edu/sem/labo/solution/sem_labs/06-07-08-09-SystemOnChip/Simulation/ramYInit.txt"
        )
        PORT MAP (
            dataIn  => memDataIn,
            dataOut => memX,
            en      => memEnX,
            clock   => clock,
            reset   => reset,
            write   => memWrX,
            addr    => addrX
        );
    I_ramy : blockRAM
        GENERIC MAP (
            addressBitNb => patternAddressBitNb,
            dataBitNb    => signalBitNb,
            initFileSpec => "C:/work/repo/edu/sem/labo/solution/sem_labs/06-07-08-09-SystemOnChip/Simulation/ramXInit.txt"
        )
        PORT MAP (
            dataIn  => memDataIn,
            dataOut => memY,
            en      => memEnY,
            clock   => clock,
            reset   => reset,
            write   => memWrY,
            addr    => addrY
        );
    I_addrx : blockRAMAddressCounter
        GENERIC MAP (
            addressBitNb => patternAddressBitNb
        )
        PORT MAP (
            en          => cntIncrX,
            clock       => clock,
            reset       => reset,
            updateMem   => updatePattern,
            addr        => addrX,
            patternSize => patternSize
        );
    I_addry : blockRAMAddressCounter
        GENERIC MAP (
            addressBitNb => patternAddressBitNb
        )
        PORT MAP (
            en          => cntIncrY,
            clock       => clock,
            reset       => reset,
            updateMem   => updatePattern,
            addr        => addrY,
            patternSize => patternSize
        );
    I_ctlx : blockRAMControl
        PORT MAP (
            memWr     => memWrX,
            sel       => selX,
            memEn     => memEnX,
            update    => updatePattern,
            wr        => write,
            cntIncr   => cntIncrX,
            newSample => newPolynom,
            clock     => clock,
            reset     => reset
        );
    I_ctly : blockRAMControl
        PORT MAP (
            memWr     => memWrY,
            sel       => selY,
            memEn     => memEnY,
            update    => updatePattern,
            wr        => write,
            cntIncr   => cntIncrY,
            newSample => newPolynom,
            clock     => clock,
            reset     => reset
        );
    I_decoder : periphAddressDecoder
        GENERIC MAP (
            addressBitNb => addressBitNb
        )
        PORT MAP (
            selControl => selControl,
            addr       => addr,
            selSpeed   => selSpeed,
            selX       => selX,
            selY       => selY,
            selZ       => OPEN
        );
    I_ctl : periphControlReg
        GENERIC MAP (
            dataBitNb        => dataBitNb,
            patternSizeBitNb => patternAddressBitNb
        )
        PORT MAP (
            run               => run_int,
            dataIn            => dataIn,
            updatePattern     => updatePattern,
            dataOut           => dataOut,
            write             => write,
            en                => selControl,
            clock             => clock,
            reset             => reset,
            interpolateLinear => interpolateLin_int,
            patternSize       => patternSize
        );
    I_speed : periphSpeedReg
        GENERIC MAP (
            dataBitNb         => dataBitNb,
            updatePeriodBitNb => updatePeriodBitNb
        )
        PORT MAP (
            updatePeriod => updatePeriod,
            dataIn       => dataIn,
            dataOut      => dataOut,
            en           => selSpeed,
            clock        => clock,
            reset        => reset,
            write        => write
        );

END struct;




--
-- VHDL Architecture SystemOnChip.ahbBeamer.struct
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:31:11 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;
-- LIBRARY AhbLite;
  use work.ahbLite.all;

-- LIBRARY SystemOnChip;

ARCHITECTURE struct OF ahbBeamer IS

    -- Architecture declarations
    constant signalBitNb: positive := 16;
    constant updatePeriodBitNb : positive := 16;

    -- Internal signal declarations
    SIGNAL reset          : std_ulogic;
    SIGNAL run            : std_ulogic;
    SIGNAL interpolateLin : std_ulogic;
    SIGNAL updatePeriod   : unsigned(updatePeriodBitNb-1 DOWNTO 0);
    SIGNAL memX           : std_ulogic_vector(signalBitNb-1 DOWNTO 0);
    SIGNAL memY           : std_ulogic_vector(signalBitNb-1 DOWNTO 0);
    SIGNAL newPolynom     : std_ulogic;


    -- Component Declarations
    COMPONENT ahbBeamerOperator
    GENERIC (
        updatePeriodBitNb : positive := 16;
        signalBitNb       : positive := 16
    );
    PORT (
        outX           : OUT    std_ulogic ;
        run            : IN     std_ulogic ;
        clock          : IN     std_ulogic ;
        reset          : IN     std_ulogic ;
        outY           : OUT    std_ulogic ;
        selSinCos      : IN     std_ulogic ;
        interpolateLin : IN     std_ulogic ;
        updatePeriod   : IN     unsigned (updatePeriodBitNb-1 DOWNTO 0);
        memX           : IN     std_ulogic_vector (signalBitNb-1 DOWNTO 0);
        memY           : IN     std_ulogic_vector (signalBitNb-1 DOWNTO 0);
        newPolynom     : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT ahbBeamerRegisters
    GENERIC (
        updatePeriodBitNb   : positive := 16;
        signalBitNb         : positive := 16;
        patternAddressBitNb : positive := 8;
        testOutBitNb        : positive := 16
    );
    PORT (
        testOut        : OUT    std_ulogic_vector (1 TO testOutBitNb);
        memX           : OUT    std_ulogic_vector (signalBitNb-1 DOWNTO 0);
        memY           : OUT    std_ulogic_vector (signalBitNb-1 DOWNTO 0);
        run            : OUT    std_ulogic ;
        updatePeriod   : OUT    unsigned (updatePeriodBitNb-1 DOWNTO 0);
        interpolateLin : OUT    std_ulogic ;
        newPolynom     : IN     std_ulogic ;
        hClk           : IN     std_ulogic ;
        hRData         : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hAddr          : IN     unsigned (ahbAddressBitNb-1 DOWNTO 0);
        hReset_n       : IN     std_ulogic ;
        hWData         : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hTrans         : IN     std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWrite         : IN     std_ulogic ;
        hSel           : IN     std_ulogic ;
        hReady         : OUT    std_ulogic ;
        hResp          : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : ahbBeamerOperator USE ENTITY SystemOnChip.ahbBeamerOperator;
--     FOR ALL : ahbBeamerRegisters USE ENTITY SystemOnChip.ahbBeamerRegisters;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 2 eb2
    --process
    --begin
    --  newPolynom <= '0';
    --  for index in 1 to 2**4-1 loop
    --    wait until rising_edge(clock);
    --  end loop;
    --  newPolynom <= '1';
    --  wait until rising_edge(clock);
    --end process;

    -- HDL Embedded Text Block 3 eb3
    reset <= not hReset_n;


    -- Instance port mappings.
    I_op : ahbBeamerOperator
        GENERIC MAP (
            updatePeriodBitNb => updatePeriodBitNb,
            signalBitNb       => signalBitNb
        )
        PORT MAP (
            outX           => outX,
            run            => run,
            clock          => hClk,
            reset          => reset,
            outY           => outY,
            selSinCos      => selSinCos,
            interpolateLin => interpolateLin,
            updatePeriod   => updatePeriod,
            memX           => memX,
            memY           => memY,
            newPolynom     => newPolynom
        );
    I_regs : ahbBeamerRegisters
        GENERIC MAP (
            updatePeriodBitNb   => updatePeriodBitNb,
            signalBitNb         => signalBitNb,
            patternAddressBitNb => patternAddressBitNb,
            testOutBitNb        => testOutBitNb
        )
        PORT MAP (
            testOut        => testOut,
            memX           => memX,
            memY           => memY,
            run            => run,
            updatePeriod   => updatePeriod,
            interpolateLin => interpolateLin,
            newPolynom     => newPolynom,
            hClk           => hClk,
            hRData         => hRData,
            hAddr          => hAddr,
            hReset_n       => hReset_n,
            hWData         => hWData,
            hTrans         => hTrans,
            hWrite         => hWrite,
            hSel           => hSel,
            hReady         => hReady,
            hResp          => hResp
        );

END struct;




-- VHDL Entity AhbLite.ahbMuxConnector.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:16 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY AhbLite;
  use work.ahbLite.all;

ENTITY ahbMuxConnector IS
    GENERIC( 
        index : positive := 1
    );
    PORT( 
        hRData  : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady  : IN     std_uLogic;
        hResp   : IN     std_uLogic;
        hSelV   : IN     std_ulogic_vector ( 1 TO ahbSlaveNb );
        hRDataV : OUT    ahbDataVector;
        hReadyV : OUT    std_logic_vector (1 TO ahbSlaveNb);
        hRespV  : OUT    std_logic_vector (1 TO ahbSlaveNb);
        hSel    : OUT    std_uLogic
    );

-- Declarations

END ahbMuxConnector ;





ARCHITECTURE RTL OF ahbMuxConnector IS
BEGIN

  hSel <= hSelV(index);

  hRDataV(index) <= std_logic_vector(hRData);
  hReadyV(index) <= hReady;
  hRespV(index)  <= hResp;

  hRDataV <= (others => (others => 'Z'));
  hReadyV <= (others => 'Z');
  hRespV  <= (others => 'Z');

END ARCHITECTURE RTL;




-- VHDL Entity AhbLite.ahbDecoder.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:16 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY AhbLite;
  use work.ahbLite.all;

ENTITY ahbDecoder IS
    GENERIC( 
        ahbMemoryLocation : ahbMemoryLocationVector
    );
    PORT( 
        hAddr : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hSel  : OUT    std_ulogic_vector (1 TO ahbSlaveNb)
    );

-- Declarations

END ahbDecoder ;





-- LIBRARY AhbLite;
  use work.ahbLite.all;

ARCHITECTURE RTL OF ahbDecoder IS
BEGIN

  decodeAddress: process(hAddr)
    variable mask: unsigned(hAddr'range);
  begin
    hSel <= (others => '0');
    for index in hSel'range loop
      mask := to_unsigned(ahbMemoryLocation(index).addressMask, mask'length);
      if (hAddr and mask) = ahbMemoryLocation(index).baseAddress then
        hSel(index) <= '1';
      end if;
    end loop;
  end process decodeAddress;

END ARCHITECTURE RTL;




-- VHDL Entity AhbLiteComponents.ahbGpio.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 11:10:19 11/30/2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY AhbLite;
  use work.ahbLite.all;

ENTITY ahbGpio IS
    GENERIC( 
        ioNb : positive := 8
    );
    PORT( 
        hAddr    : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hClk     : IN     std_uLogic;
        hReset_n : IN     std_uLogic;
        hSel     : IN     std_uLogic;
        hTrans   : IN     std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWData   : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hWrite   : IN     std_uLogic;
        ioIn     : IN     std_ulogic_vector (ioNb-1 DOWNTO 0);
        hRData   : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady   : OUT    std_uLogic;
        hResp    : OUT    std_uLogic;
        ioEn     : OUT    std_ulogic_vector (ioNb-1 DOWNTO 0);
        ioOut    : OUT    std_ulogic_vector (ioNb-1 DOWNTO 0)
    );

-- Declarations

END ahbGpio ;





--==============================================================================
--
-- AHB general purpose input/outputs
--
-- Provides "ioNb" input/output signals .
--
--------------------------------------------------------------------------------
--
-- Write registers
--
-- 00, data register receives the values to drive the output lines.
-- 01, output enable register defines the signal direction:
--     when '1', the direction is "out".
--
--------------------------------------------------------------------------------
--
-- Read registers
-- 00, data register provides the values detected on the lines.
--

ARCHITECTURE masterVersion OF ahbGpio IS

  signal reset, clock: std_ulogic;
                                                         -- register definitions
  constant dataRegisterId: natural := 0;
  constant outputEnableRegisterId: natural := 1;

  signal addressReg: unsigned(addressBitNb(outputEnableRegisterId)-1 downto 0);
  signal writeReg: std_ulogic;
                                                            -- written registers
  subtype registerType is unsigned(ioNb-1 downto 0);
  signal dataOutRegister, outputEnableRegister: registerType;
                                                               -- read registers
  signal dataInRegister : registerType;

BEGIN
  ------------------------------------------------------------------------------
                                                              -- reset and clock
  reset <= not hReset_n;
  clock <= hClk;

  --============================================================================
                                                         -- address and controls
  storeControls: process(reset, clock)
  begin
    if reset = '1' then
      addressReg <= (others => '0');
      writeReg <= '0';
    elsif rising_edge(clock) then
      writeReg <= '0';
      if (hSel = '1') and (hTrans = transNonSeq) then
        addressReg <= hAddr(addressReg'range);
        writeReg <= hWrite;
      end if;
    end if;
  end process storeControls;

  --============================================================================
                                                                    -- registers
  storeWriteRegisters: process(reset, clock)
  begin
    if reset = '1' then
      dataOutRegister <= (others => '0');
      outputEnableRegister <= (others => '0');
    elsif rising_edge(clock) then
      if writeReg = '1' then
        case to_integer(addressReg) is
          when dataRegisterId         => dataOutRegister <= unsigned(hWData(dataOutRegister'range));
          when outputEnableRegisterId => outputEnableRegister <= unsigned(hWData(outputEnableRegister'range));
          when others => null;
        end case;
      end if;
    end if;
  end process storeWriteRegisters;

  ioOut <= std_ulogic_vector(dataOutRegister);
  ioEn <= std_ulogic_vector(outputEnableRegister);

  --============================================================================
                                                                -- data readback
  dataInRegister <= unsigned(ioIn);

  hRData <= std_ulogic_vector(resize(dataInRegister, hRData'length));
  hReady <= '1';  -- no wait state
  hResp  <= '0';  -- data OK


END ARCHITECTURE masterVersion;




-- VHDL Entity AhbLite.ahbMasterInterface.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:16 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY AhbLite;
  use work.ahbLite.all;

ENTITY ahbMasterInterface IS
    PORT( 
        clock        : IN     std_ulogic;
        hRData       : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady       : IN     std_uLogic;
        hResp        : IN     std_uLogic;
        pAddress     : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        pDataOut     : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        pReadStrobe  : IN     std_uLogic;
        pWriteStrobe : IN     std_uLogic;
        reset        : IN     std_ulogic;
        hAddr        : OUT    unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hBurst       : OUT    std_ulogic_vector (ahbBurstBitNb-1 DOWNTO 0);
        hClk         : OUT    std_uLogic;
        hMastLock    : OUT    std_uLogic;
        hProt        : OUT    std_ulogic_vector (ahbProtBitNb-1 DOWNTO 0);
        hReset_n     : OUT    std_uLogic;
        hSize        : OUT    std_ulogic_vector (ahbSizeBitNb-1 DOWNTO 0);
        hTrans       : OUT    std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWData       : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hWrite       : OUT    std_uLogic;
        pDataIn      : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0)
    );

-- Declarations

END ahbMasterInterface ;





ARCHITECTURE RTL OF ahbMasterInterface IS

  signal addressReg: unsigned(pAddress'range);
  signal newAddress: std_ulogic;
  signal writeReg: std_ulogic;

BEGIN
  ------------------------------------------------------------------------------
                                                              -- reset and clock
  hReset_n <= not reset;
  hClk <= clock;

  ------------------------------------------------------------------------------
                                                         -- address and controls
  newAddress <= pReadStrobe or pWriteStrobe;

  storeAddress: process(reset, clock)
  begin
    if reset = '1' then
      addressReg <= (others => '0');
    elsif rising_edge(clock) then
      if newAddress = '1' then
        addressReg <= pAddress;
      end if;
    end if;
  end process storeAddress;

  hAddr <= pAddress when newAddress = '1'
    else addressReg;

  storeWrite: process(reset, clock)
  begin
    if reset = '1' then
      writeReg <= '0';
    elsif rising_edge(clock) then
      if newAddress = '1' then
        writeReg <= pWriteStrobe;
      end if;
    end if;
  end process storeWrite;

  hWrite <= pWriteStrobe when newAddress = '1'
    else writeReg;

  hTrans <= transNonSeq when newAddress = '1'
    else transIdle;

  hSize <= size16;
  hBurst <= burstSingle;
  hProt <= protDefault;
  hMastLock <= '0';

  ------------------------------------------------------------------------------
                                                                     -- data out
  delayData: process(reset, clock)
  begin
    if reset = '1' then
      hWData <= (others => '0');
    elsif rising_edge(clock) then
      if pWriteStrobe = '1' then
        hWData <= pDataOut;
      end if;
    end if;
  end process delayData;

  ------------------------------------------------------------------------------
                                                                      -- data in
  pDataIn <= hRData;

END ARCHITECTURE RTL;




-- VHDL Entity AhbLite.ahbMultiplexor.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:16 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY AhbLite;
  use work.ahbLite.all;

ENTITY ahbMultiplexor IS
    PORT( 
        hRDataV : IN     ahbDataVector;
        hReadyV : IN     std_logic_vector (1 TO ahbSlaveNb);
        hRespV  : IN     std_logic_vector (1 TO ahbSlaveNb);
        hSel    : IN     std_ulogic_vector ( 1 TO ahbSlaveNb );
        hRData  : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady  : OUT    std_uLogic;
        hResp   : OUT    std_uLogic
    );

-- Declarations

END ahbMultiplexor ;





ARCHITECTURE RTL OF ahbMultiplexor IS
BEGIN

  multiplexData: process(hSel, hRDataV, hReadyV, hRespV)
  begin
    hRData <= (others => '0');
    hReady <= '1';
    hResp  <= '0';
    for index in hSel'range loop
      if hSel(index) = '1' then
        hRData <= std_ulogic_vector(hRDataV(index));
        hReady <= hReadyV(index);
        hResp  <= hRespV(index);
      end if;
    end loop;
  end process multiplexData;

END ARCHITECTURE RTL;




-- VHDL Entity SystemOnChip.programRom.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:40:20 03/13/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY programRom IS
    GENERIC( 
        addressBitNb : positive := 8;
        dataBitNb    : positive := 8
    );
    PORT( 
        address : IN     unsigned (addressBitNb-1 DOWNTO 0);
        clock   : IN     std_ulogic;
        en      : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector ( dataBitNb-1 DOWNTO 0 )
    );

-- Declarations

END programRom ;





ARCHITECTURE mapped OF programRom IS

  subtype opCodeType is std_ulogic_vector(5 downto 0);
  constant opLoadC   : opCodeType := "000000";
  constant opLoadR   : opCodeType := "000001";
  constant opInputC  : opCodeType := "000100";
  constant opInputR  : opCodeType := "000101";
  constant opFetchC  : opCodeType := "000110";
  constant opFetchR  : opCodeType := "000111";
  constant opAndC    : opCodeType := "001010";
  constant opAndR    : opCodeType := "001011";
  constant opOrC     : opCodeType := "001100";
  constant opOrR     : opCodeType := "001101";
  constant opXorC    : opCodeType := "001110";
  constant opXorR    : opCodeType := "001111";
  constant opTestC   : opCodeType := "010010";
  constant opTestR   : opCodeType := "010011";
  constant opCompC   : opCodeType := "010100";
  constant opCompR   : opCodeType := "010101";
  constant opAddC    : opCodeType := "011000";
  constant opAddR    : opCodeType := "011001";
  constant opAddCyC  : opCodeType := "011010";
  constant opAddCyR  : opCodeType := "011011";
  constant opSubC    : opCodeType := "011100";
  constant opSubR    : opCodeType := "011101";
  constant opSubCyC  : opCodeType := "011110";
  constant opSubCyR  : opCodeType := "011111";
  constant opShRot   : opCodeType := "100000";
  constant opOutputC : opCodeType := "101100";
  constant opOutputR : opCodeType := "101101";
  constant opStoreC  : opCodeType := "101110";
  constant opStoreR  : opCodeType := "101111";

  subtype shRotCinType is std_ulogic_vector(2 downto 0);
  constant shRotLdC : shRotCinType := "00-";
  constant shRotLdM : shRotCinType := "01-";
  constant shRotLdL : shRotCinType := "10-";
  constant shRotLd0 : shRotCinType := "110";
  constant shRotLd1 : shRotCinType := "111";

  constant registerAddressBitNb : positive := 4;
  constant shRotPadLength : positive
    := dataOut'length - opCodeType'length - registerAddressBitNb
     - 1 - shRotCinType'length;
  subtype shRotDirType is std_ulogic_vector(1+shRotPadLength-1 downto 0);
  constant shRotL : shRotDirType := (0 => '0', others => '-');
  constant shRotR : shRotDirType := (0 => '1', others => '-');

  subtype branchCodeType is std_ulogic_vector(4 downto 0);
  constant brRet  : branchCodeType := "10101";
  constant brCall : branchCodeType := "11000";
  constant brJump : branchCodeType := "11010";
  constant brReti : branchCodeType := "11100";
  constant brEni  : branchCodeType := "11110";

  subtype branchConditionType is std_ulogic_vector(2 downto 0);
  constant brDo : branchConditionType := "000";
  constant brZ  : branchConditionType := "100";
  constant brNZ : branchConditionType := "101";
  constant brC  : branchConditionType := "110";
  constant brNC : branchConditionType := "111";

  subtype memoryWordType is std_ulogic_vector(dataOut'range);
  type memoryArrayType is array (0 to 2**address'length-1) of memoryWordType;

  signal memoryArray : memoryArrayType := (
                                                         --===============================================================
                                                         -- Beamer control
                                                         --===============================================================
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- register definitions
                                                         --   s0, s1: used for INPUT and OUTPUT operations
                                                         --   S2: returns UART data byte
                                                         --   S3: uart protocol checksum
                                                         --   S4: uart protocol packet id
                                                         --   S5: uart protocol command id
                                                         --   S6: uart protocol address
                                                         --   S7: uart protocol data
                                                         --   S8: copy of UART data byte for debug
                                                         -----------------------------------------------------------------
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- GPIO definitions
                                                         -----------------------------------------------------------------
                                                         -----------------------------------------------------------------
                                                         -- UART definitions
                                                         -----------------------------------------------------------------
                                                         --                CONSTANT  uartBaudCount,    023D        ; 66E6 / 115 200 = 573
                                                         --                CONSTANT  uartpollDelay,    0100
                                                         -----------------------------------------------------------------
                                                         -- beamer peripheral definitions
                                                         -----------------------------------------------------------------
                                                         --                CONSTANT  beamerCtlInit,    1001
                                                         --
                                                         --===============================================================
                                                         -- initializations
                                                         --===============================================================
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- initialize GPIO
                                                         -----------------------------------------------------------------
    16#000# => opLoadC   & "0000" & "0000000000000000",  -- LOAD      s0, 0000
    16#001# => opAddC    & "0000" & "0000000000000000",  -- ADD       s0, 0000
    16#002# => opLoadC   & "0001" & "0000000010101010",  -- LOAD      s1, AA
    16#003# => opOutputR & "0001" & "0000------------",  -- OUTPUT    s1, (S0)
    16#004# => opLoadC   & "0000" & "0000000000000000",  -- LOAD      s0, 0000
    16#005# => opAddC    & "0000" & "0000000000000001",  -- ADD       s0, 0001
    16#006# => opLoadC   & "0001" & "0000000000001111",  -- LOAD      s1, 0F
    16#007# => opOutputR & "0001" & "0000------------",  -- OUTPUT    s1, (S0)
                                                         -----------------------------------------------------------------
                                                         -- initialize UART
                                                         -----------------------------------------------------------------
    16#008# => opLoadC   & "0000" & "0000000000010000",  -- LOAD      s0, 0010
    16#009# => opAddC    & "0000" & "0000000000000010",  -- ADD       s0, 0002
    16#00A# => opLoadC   & "0001" & "0000000001000010",  -- LOAD      s1, 0042
    16#00B# => opOutputR & "0001" & "0000------------",  -- OUTPUT    s1, (S0)
                                                         -----------------------------------------------------------------
                                                         -- initialize beamer peripheral
                                                         -----------------------------------------------------------------
    16#00C# => opLoadC   & "0000" & "0000000000100000",  -- LOAD      s0, 0020
    16#00D# => opAddC    & "0000" & "0000000000000000",  -- ADD       s0, 0000
    16#00E# => opLoadC   & "0001" & "0000010000000001",  -- LOAD      s1, 0401
    16#00F# => opOutputR & "0001" & "0000------------",  -- OUTPUT    s1, (S0)
    16#010# => opLoadC   & "0000" & "0000000000100000",  -- LOAD      s0, 0020
    16#011# => opAddC    & "0000" & "0000000000000001",  -- ADD       s0, 0001
    16#012# => opLoadC   & "0001" & "0000000000000100",  -- LOAD      s1, 0004
    16#013# => opOutputR & "0001" & "0000------------",  -- OUTPUT    s1, (S0)
                                                         --
                                                         --===============================================================
                                                         -- Main loop
                                                         --===============================================================
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- Process commands from serial port
                                                         -----------------------------------------------------------------
                                                         -- _main_:
    16#014# => brCall    & brDo   & "--------0000100001",-- CALL      021        ; get command from UART
    16#015# => opCompC   & "0011" & "0000000000000000",  -- COMPARE   s3, 0000   ; check function return
    16#016# => brJump    & brNZ   & "--------0000011111",-- JUMP      NZ, 01F
    16#017# => opCompC   & "0101" & "0000000000000011",  -- COMPARE   s5, 0003   ; check for WRITE_MEM command
    16#018# => brJump    & brNZ   & "--------0000011100",-- JUMP      NZ, 01C
    16#019# => opOutputR & "0111" & "0110------------",  -- OUTPUT    s7, (S6)   ; write word to memory location
    16#01A# => brCall    & brDo   & "--------0001100000",-- CALL      060        ; send write acknowledge
    16#01B# => brJump    & brDo   & "--------0000010100",-- JUMP      014
                                                         -- _commandRead_:
    16#01C# => opInputR  & "0111" & "0110------------",  -- INPUT     s7, (S6)   ; write word in memory location
    16#01D# => brCall    & brDo   & "--------0001101111",-- CALL      06F        ; send back read data
    16#01E# => brJump    & brDo   & "--------0000010100",-- JUMP      014
                                                         -- _commandAbort_:
    16#01F# => brCall    & brDo   & "--------0001010001",-- CALL      051
    16#020# => brJump    & brDo   & "--------0000010100",-- JUMP      014
                                                         --
                                                         --===============================================================
                                                         -- Subroutines
                                                         --===============================================================
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- Get command from serial port
                                                         -----------------------------------------------------------------
                                                         -- _uartGetCmd_:
    16#021# => brCall    & brDo   & "--------0010000110",-- CALL      086        ; get command header
    16#022# => opCompC   & "0010" & "0000000010101010",  -- COMPARE   s2, 00AA
    16#023# => brJump    & brNZ   & "--------0000100001",-- JUMP      NZ, 021    ; loop until byte is AAh
    16#024# => opLoadR   & "0011" & "0010------------",  -- LOAD      s3, s2     ; prepare checksum
    16#025# => brCall    & brDo   & "--------0010000110",-- CALL      086        ; get packet id
    16#026# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#027# => opLoadR   & "0100" & "0010------------",  -- LOAD      s4, s2     ; store id for reply
    16#028# => brCall    & brDo   & "--------0010000110",-- CALL      086        ; get command
    16#029# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#02A# => opCompC   & "0010" & "0000000000000011",  -- COMPARE   s2, 0003   ; check for WRITE_MEM command
    16#02B# => brJump    & brZ    & "--------0000101111",-- JUMP      Z, 02F
    16#02C# => opCompC   & "0010" & "0000000000000100",  -- COMPARE   s2, 0004   ; check for READ_MEM command
    16#02D# => brJump    & brZ    & "--------0000101111",-- JUMP      Z, 02F
    16#02E# => brJump    & brDo   & "--------0001001111",-- JUMP      04F        ; no match
                                                         -- _commandOk_:
    16#02F# => opLoadR   & "0101" & "0010------------",  -- LOAD      s5, s2     ; store command for action
    16#030# => brCall    & brDo   & "--------0010000110",-- CALL      086        ; get data length
    16#031# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#032# => opCompC   & "0101" & "0000000000000011",  -- COMPARE   s5, 0003   ; check for WRITE_MEM command
    16#033# => brJump    & brZ    & "--------0000110111",-- JUMP      Z, 037     ; go to test write command length
    16#034# => opCompC   & "0010" & "0000000000000010",  -- COMPARE   s2, 0002   ; verify READ_MEM length
    16#035# => brJump    & brNZ   & "--------0001001111",-- JUMP      NZ, 04F
    16#036# => brJump    & brDo   & "--------0000111001",-- JUMP      039
                                                         -- _testWrLength_:
    16#037# => opCompC   & "0010" & "0000000000000100",  -- COMPARE   s2, 0004   ; verify WRITE_MEM length
    16#038# => brJump    & brNZ   & "--------0001001111",-- JUMP      NZ, 04F
                                                         -- _getAddress_:
    16#039# => brCall    & brDo   & "--------0010000110",-- CALL      086        ; get address low
    16#03A# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#03B# => opLoadR   & "0110" & "0010------------",  -- LOAD      s6, s2     ; store address low
    16#03C# => brCall    & brDo   & "--------0010000110",-- CALL      086        ; get address high
    16#03D# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#03E# => brCall    & brDo   & "--------0010100000",-- CALL      0A0
    16#03F# => opAddR    & "0110" & "0010------------",  -- ADD       s6, s2     ; build address from low and high
    16#040# => opCompC   & "0101" & "0000000000000100",  -- COMPARE   s5, 0004   ; check for READ_MEM command
    16#041# => brJump    & brZ    & "--------0001001001",-- JUMP      Z, 049     ; skip reading data word
    16#042# => brCall    & brDo   & "--------0010000110",-- CALL      086        ; get data low
    16#043# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#044# => opLoadR   & "0111" & "0010------------",  -- LOAD      s7, s2     ; store data low
    16#045# => brCall    & brDo   & "--------0010000110",-- CALL      086        ; get data high
    16#046# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#047# => brCall    & brDo   & "--------0010100000",-- CALL      0A0
    16#048# => opAddR    & "0111" & "0010------------",  -- ADD       s7, s2     ; build data from low and high
                                                         -- _getChecksum_:
    16#049# => brCall    & brDo   & "--------0010000110",-- CALL      086        ; get checksum
    16#04A# => opAndC    & "0011" & "0000000011111111",  -- AND       s3, 00FF   ; limit calculated checksum to 8 bit
    16#04B# => opCompR   & "0011" & "0010------------",  -- COMPARE   s3, s2     ; test checksum
    16#04C# => brJump    & brNZ   & "--------0001001111",-- JUMP      NZ, 04F
    16#04D# => opLoadC   & "0011" & "0000000000000000",  -- LOAD      s3, 0000   ; return OK
    16#04E# => brRet     & brDo   & "------------------",-- RETURN
                                                         -- _commandKo_:
    16#04F# => opLoadC   & "0011" & "0000000000000001",  -- LOAD      s3, 0001   ; return KO
    16#050# => brRet     & brDo   & "------------------",-- RETURN
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- send NACK reply
                                                         -----------------------------------------------------------------
                                                         -- _sendNAck_:
    16#051# => opLoadC   & "0010" & "0000000010101010",  -- LOAD      s2, 00AA   ; send header
    16#052# => opLoadR   & "0011" & "0010------------",  -- LOAD      s3, s2     ; prepare checksum
    16#053# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#054# => opLoadR   & "0010" & "0100------------",  -- LOAD      s2, s4     ; packet id
    16#055# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#056# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#057# => opLoadC   & "0010" & "0000000000000000",  -- LOAD      s2, 0000   ; negative Acknowledge
    16#058# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#059# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#05A# => opLoadC   & "0010" & "0000000000000000",  -- LOAD      s2, 0000   ; packet length: no data
    16#05B# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#05C# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#05D# => opLoadR   & "0010" & "0011------------",  -- LOAD      s2, s3     ; checksum
    16#05E# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#05F# => brRet     & brDo   & "------------------",-- RETURN
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- send WRITE_MEM reply
                                                         -----------------------------------------------------------------
                                                         -- _sendWriteOk_:
    16#060# => opLoadC   & "0010" & "0000000010101010",  -- LOAD      s2, 00AA   ; send header
    16#061# => opLoadR   & "0011" & "0010------------",  -- LOAD      s3, s2     ; prepare checksum
    16#062# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#063# => opLoadR   & "0010" & "0100------------",  -- LOAD      s2, s4     ; packet id
    16#064# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#065# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#066# => opLoadR   & "0010" & "0101------------",  -- LOAD      s2, s5     ; received command
    16#067# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#068# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#069# => opLoadC   & "0010" & "0000000000000000",  -- LOAD      s2, 0000   ; packet length: no data
    16#06A# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#06B# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#06C# => opLoadR   & "0010" & "0011------------",  -- LOAD      s2, s3     ; checksum
    16#06D# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#06E# => brRet     & brDo   & "------------------",-- RETURN
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- send READ_MEM reply
                                                         -----------------------------------------------------------------
                                                         -- _sendReadData_:
    16#06F# => opLoadC   & "0010" & "0000000010101010",  -- LOAD      s2, 00AA   ; send header
    16#070# => opLoadR   & "0011" & "0010------------",  -- LOAD      s3, s2     ; prepare checksum
    16#071# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#072# => opLoadR   & "0010" & "0100------------",  -- LOAD      s2, s4     ; packet id
    16#073# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#074# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#075# => opLoadR   & "0010" & "0101------------",  -- LOAD      s2, s5     ; received command
    16#076# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#077# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#078# => opLoadC   & "0010" & "0000000000000010",  -- LOAD      s2, 0002   ; packet length: 2 bytes
    16#079# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#07A# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#07B# => opLoadR   & "0010" & "0111------------",  -- LOAD      s2, s7     ; data low
    16#07C# => opAndC    & "0010" & "0000000011111111",  -- AND       s2, 00FF   ; keep low byte only
    16#07D# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#07E# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#07F# => opLoadR   & "0010" & "0111------------",  -- LOAD      s2, s7     ; data high
    16#080# => brCall    & brDo   & "--------0010100101",-- CALL      0A5        ; shift MSBs down to LSBs
    16#081# => opAddR    & "0011" & "0010------------",  -- ADD       s3, s2     ; calculate checksum
    16#082# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#083# => opLoadR   & "0010" & "0011------------",  -- LOAD      s2, s3     ; checksum
    16#084# => brCall    & brDo   & "--------0010010011",-- CALL      093
    16#085# => brRet     & brDo   & "------------------",-- RETURN
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- Get byte from serial port
                                                         -----------------------------------------------------------------
                                                         -- _uartGetByte_:
    16#086# => opLoadC   & "0000" & "0000000000010000",  -- LOAD      s0, 0010   ; read UART satus register
    16#087# => opAddC    & "0000" & "0000000000000001",  -- ADD       s0, 01
                                                         --load s8, 0100
                                                         -- _checkStat_:
    16#088# => opLoadC   & "0010" & "0000000001000000",  -- LOAD      s2, 0040   ; add delay between bus reads
                                                         -- _delay0_:
    16#089# => opSubC    & "0010" & "0000000000000001",  -- SUB       s2, 0001
    16#08A# => brJump    & brNZ   & "--------0010001001",-- JUMP      NZ, 089
                                                         --sub s8, 0001
                                                         --jump nz, continue
                                                         --load s2, 0035
                                                         --call uartSendByte
                                                         --load s8, 0100
                                                         -- _continue_:
    16#08B# => opInputR  & "0001" & "0000------------",  -- INPUT     s1, (S0)
    16#08C# => opInputR  & "0001" & "0000------------",  -- INPUT     s1, (S0)
    16#08D# => opTestC   & "0001" & "0000000000000001",  -- TEST      s1, 0001   ; check "data ready" bit
    16#08E# => brJump    & brZ    & "--------0010001000",-- JUMP      Z, 088     ; loop until bit is '1'
    16#08F# => opLoadC   & "0000" & "0000000000010000",  -- LOAD      s0, 0010   ; read UART data register
    16#090# => opInputR  & "0010" & "0000------------",  -- INPUT     s2, (S0)
    16#091# => opInputR  & "0010" & "0000------------",  -- INPUT     s2, (S0)
                                                         --LOAD s8, s2
    16#092# => brRet     & brDo   & "------------------",-- RETURN
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- Send byte to serial port
                                                         -----------------------------------------------------------------
                                                         -- _uartSendByte_:
    16#093# => opLoadC   & "0000" & "0000000000010000",  -- LOAD      s0, 0010   ; read UART satus register
    16#094# => opAddC    & "0000" & "0000000000000001",  -- ADD       s0, 0001
                                                         -- _readStatus_:
    16#095# => opInputR  & "0001" & "0000------------",  -- INPUT     s1, (S0)
    16#096# => opInputR  & "0001" & "0000------------",  -- INPUT     s1, (S0)
    16#097# => opTestC   & "0001" & "0000000000000010",  -- TEST      s1, 0002   ; check "sending data" bit
    16#098# => brJump    & brZ    & "--------0010011101",-- JUMP      Z, 09D     ; loop until bit is '1'
    16#099# => opLoadC   & "0001" & "0000000001000000",  -- LOAD      s1, 0040   ; add delay between bus reads
                                                         -- _delay1_:
    16#09A# => opSubC    & "0001" & "0000000000000001",  -- SUB       s1, 0001
    16#09B# => brJump    & brNZ   & "--------0010011010",-- JUMP      NZ, 09A
    16#09C# => brJump    & brDo   & "--------0010010101",-- JUMP      095
                                                         -- _sendByte_:
    16#09D# => opLoadC   & "0000" & "0000000000010000",  -- LOAD      s0, 0010   ; write UART data register
    16#09E# => opOutputR & "0010" & "0000------------",  -- OUTPUT    s2, (S0)
    16#09F# => brRet     & brDo   & "------------------",-- RETURN
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- shift s2 8 bits to the left
                                                         -----------------------------------------------------------------
                                                         -- _shiftS2L8_:
    16#0A0# => opLoadC   & "0000" & "0000000000001000",  -- LOAD      s0, 8      ; loop count
                                                         -- _shiftLeftLoop_:
    16#0A1# => opShRot   & "0010" & shRotL & shRotLd0,   -- SL0       s2
    16#0A2# => opSubC    & "0000" & "0000000000000001",  -- SUB       s0, 0001
    16#0A3# => brJump    & brNZ   & "--------0010100001",-- JUMP      NZ, 0A1
    16#0A4# => brRet     & brDo   & "------------------",-- RETURN
                                                         --
                                                         -----------------------------------------------------------------
                                                         -- shift s2 8 bits to the right
                                                         -----------------------------------------------------------------
                                                         -- _shiftS2R8_:
    16#0A5# => opLoadC   & "0000" & "0000000000001000",  -- LOAD      s0, 8      ; loop count
                                                         -- _shiftRightLoop_:
    16#0A6# => opShRot   & "0010" & shRotR & shRotLd0,   -- SR0       s2
    16#0A7# => opSubC    & "0000" & "0000000000000001",  -- SUB       s0, 0001
    16#0A8# => brJump    & brNZ   & "--------0010100110",-- JUMP      NZ, 0A6
    16#0A9# => brRet     & brDo   & "------------------",-- RETURN
                                                         --
                                                         --===============================================================
                                                         -- End of instruction memory
                                                         --===============================================================
                                                         -- _endOfMemory_:
    16#3FF# => brJump    & brDo   & "--------1111111111",-- JUMP      3FF
    others => (others => '0')
  );

BEGIN

  process (clock)
  begin
    if rising_edge(clock) then
      if en = '1' then
        dataOut <= memoryArray(to_integer(address));
      end if;
    end if;
  end process;

END ARCHITECTURE mapped;




-- VHDL Entity AhbLiteComponents.ahbUart.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 11:10:19 11/30/2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY AhbLite;
  use work.ahbLite.all;

ENTITY ahbUart IS
    GENERIC( 
        txFifoDepth : positive := 8;
        rxFifoDepth : positive := 1
    );
    PORT( 
        RxD      : IN     std_ulogic;
        hAddr    : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hClk     : IN     std_uLogic;
        hReset_n : IN     std_uLogic;
        hSel     : IN     std_uLogic;
        hTrans   : IN     std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWData   : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hWrite   : IN     std_uLogic;
        TxD      : OUT    std_ulogic;
        hRData   : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady   : OUT    std_uLogic;
        hResp    : OUT    std_uLogic
    );

-- Declarations

END ahbUart ;





--==============================================================================
--
-- AHB UART
--
-- Implements a serial port.
--
--------------------------------------------------------------------------------
--
-- Write registers
--
-- 00, data register receives the word to be sent to the serial port.
-- 01, control register is used to control the peripheral.
-- 02, scaler register is used to set the baud rate.
--
--------------------------------------------------------------------------------
--
-- Read registers
-- 00, data register provides the last word received by the serial port.
-- 01, status register is used to get the peripheral's state.
--     bit 0: data ready for read
--     bit 1: sending in progress
--     bit 2: receiving in progress
--

ARCHITECTURE masterVersion OF ahbUart IS

  signal reset, clock: std_ulogic;
                                                         -- register definitions
  constant dataOutRegisterId: natural := 0;
  constant dataBitNb: positive := 8;
  constant controlRegisterId: natural := 1;
  constant controlBpoId: natural := 0;
  constant controlFormatId: natural := 0;
  constant scalerRegisterId: natural := 2;

  constant statusRegisterId: natural := 1;
  constant statusReadyId: natural := 0;
  constant statusSendingId: natural := 1;
  constant statusReceivingId: natural := 2;
                                                            -- written registers
  signal addressReg: unsigned(addressBitNb(scalerRegisterId)+1-1 downto 0);
  signal writeReg: std_ulogic;
  signal readReg: std_ulogic;
  subtype registerType is unsigned(hWdata'length-1 downto 0);
  signal dataOutRegister : unsigned(dataBitNb-1 downto 0);
  signal controlRegister, scalerRegister: registerType;
                                                                   -- serializer
  signal txPeriodCounter: unsigned(registerType'range);
  signal txEn: std_uLogic;
  signal txStart: std_uLogic;
  signal txSending: std_uLogic;
  signal txShiftCounter : unsigned(addressBitNb(dataOutRegister'length+2)-1 downto 0);
  signal txShiftRegister : unsigned(dataOutRegister'high+1 downto 0);
                                                               -- read registers
  signal dataInRegister : unsigned(dataOutRegister'range);
  signal statusRegister: registerType;
                                                                 -- deserializer
  signal rxPeriodCounter: unsigned(registerType'range);
  signal rxEn: std_uLogic;
  signal rxDelayed, rxChanged: std_uLogic;
  signal rxShiftCounter : unsigned(txShiftCounter'range);
  signal rxReceiving: std_uLogic;
  signal rxShiftRegister : unsigned(dataInRegister'range);
  signal rxDataReady: std_uLogic;

BEGIN
  ------------------------------------------------------------------------------
                                                              -- reset and clock
  reset <= not hReset_n;
  clock <= hClk;

  --============================================================================
                                                         -- address and controls
  storeControls: process(reset, clock)
  begin
    if reset = '1' then
      addressReg <= (others => '0');
      writeReg <= '0';
      readReg <= '0';
    elsif rising_edge(clock) then
      writeReg <= '0';
      readReg <= '0';
      if (hSel = '1') and (hTrans = transNonSeq) then
        addressReg <= hAddr(addressReg'range);
        writeReg <= hWrite;
        readReg <= not hWrite;
      end if;
    end if;
  end process storeControls;

  --============================================================================
                                                                    -- registers
  storeWriteRegisters: process(reset, clock)
  begin
    if reset = '1' then
      dataOutRegister <= (others => '0');
      controlRegister <= (others => '0');
      scalerRegister <= (others => '0');
    elsif rising_edge(clock) then
      if writeReg = '1' then
        case to_integer(addressReg) is
          when dataOutRegisterId    => dataOutRegister <= unsigned(hWData(dataOutRegister'range));
          when controlRegisterId => controlRegister <= unsigned(hWData);
          when scalerRegisterId  => scalerRegister <= unsigned(hWData);
          when others => null;
        end case;
      end if;
    end if;
  end process storeWriteRegisters;

  txStart <= '1' when (writeReg = '1') and (addressReg = dataOutRegisterId)
    else '0';

  --============================================================================
                                                                   -- serializer
                                                                 -- tx baud rate
  countTxBaudRate: process(reset, clock)
  begin
    if reset = '1' then
      txPeriodCounter <= (others => '1');
    elsif rising_edge(clock) then
      if txPeriodCounter + 1 < scalerRegister then
        txPeriodCounter <= txPeriodCounter + 1;
      else
        txPeriodCounter <= (others => '0');
      end if;
    end if;
  end process countTxBaudRate;

  txEn <= '1' when txPeriodCounter = 1
    else '0';
                                                               -- count tx shift
  countTxShift: process(reset, clock)
  begin
    if reset = '1' then
      txShiftCounter <= (others => '0');
    elsif rising_edge(clock) then
      if txShiftCounter = 0 then
        if txStart = '1' then
          txShiftCounter <= txShiftCounter + 1;
        end if;
      elsif txEn = '1' then
        if txShiftCounter < dataOutRegister'length + 3 then
          txShiftCounter <= txShiftCounter + 1;
        else
          txShiftCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countTxShift;

  txSending <= '1' when txShiftCounter /= 0
    else '0';
                                                                -- tx serializer
  shiftTxData: process(reset, clock)
  begin
    if reset = '1' then
      txShiftRegister <= (others => '1');
    elsif rising_edge(clock) then
      if txEn = '1' then
        if txShiftCounter = 1 then
          txShiftRegister <= dataOutRegister & '0';
        else
          txShiftRegister <= shift_right(txShiftRegister, 1);
          txShiftRegister(txShiftRegister'high) <= '1';
        end if;
      end if;
    end if;
  end process shiftTxData;

  TxD <= txShiftRegister(0);

  --============================================================================
                                                                 -- deserializer
  delayRxd: process(reset, clock)
  begin
    if reset = '1' then
      rxDelayed <= '0';
    elsif rising_edge(clock) then
      rxDelayed <= RxD;
    end if;
  end process delayRxd;

  rxChanged <= '1' when rxDelayed /= RxD
    else '0';
                                                                 -- rx baud rate
  countRxBaudRate: process(reset, clock)
  begin
    if reset = '1' then
      rxPeriodCounter <= (others => '1');
    elsif rising_edge(clock) then
      if rxChanged = '1' then
        rxPeriodCounter <= (others => '0');
      elsif rxPeriodCounter + 1 < scalerRegister then
        rxPeriodCounter <= rxPeriodCounter + 1;
      else
        rxPeriodCounter <= (others => '0');
      end if;
    end if;
  end process countRxBaudRate;

  rxEn <= '1' when rxPeriodCounter = shift_right(scalerRegister-2, 1)
    else '0';
                                                               -- count rx shift
  countRxShift: process(reset, clock)
  begin
    if reset = '1' then
      rxShiftCounter <= (others => '0');
    elsif rising_edge(clock) then
      if rxShiftCounter = 0 then
        if (RxD = '0') and (rxDelayed = '1') then
          rxShiftCounter <= rxShiftCounter + 1;
        end if;
      elsif rxEn = '1' then
        if rxShiftCounter < dataInRegister'length + 2 then
          rxShiftCounter <= rxShiftCounter + 1;
        else
          rxShiftCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countRxShift;

  rxReceiving <= '1' when rxShiftCounter /= 0
    else '0';
                                                              -- rx deserializer
  shiftRxData: process(reset, clock)
  begin
    if reset = '1' then
      rxShiftRegister <= (others => '1');
      dataInRegister <= (others => '0');
    elsif rising_edge(clock) then
      if rxEn = '1' then
        if rxShiftCounter <= dataInRegister'length+1 then
          rxShiftRegister <= shift_right(rxShiftRegister, 1);
          rxShiftRegister(rxShiftRegister'high) <= RxD;
        end if;
        if rxShiftCounter = dataInRegister'length+2 then
          dataInRegister <= rxShiftRegister;
        end if;
      end if;
    end if;
  end process shiftRxData;
                                                           -- monitor data ready
  checkDataReady: process(reset, clock)
  begin
    if reset = '1' then
      rxDataReady <= '0';
    elsif rising_edge(clock) then
      if (rxEn = '1') and (rxShiftCounter = dataInRegister'length+2) then
        rxDataReady <= '1';
      elsif (readReg = '1') and (addressReg = dataOutRegisterId) then
        rxDataReady <= '0';
      end if;
    end if;
  end process checkDataReady;

  --============================================================================
                                                                -- data readback
  statusRegister <= (
    statusReadyId     => rxDataReady,
    statusSendingId   => txSending,
    statusReceivingId => rxReceiving,
    others            => '0'
  );

  selectData: process(addressReg, dataInRegister, statusRegister)
  begin
    hRData <= (others => '-');
    case to_integer(addressReg) is
      when dataOutRegisterId => hRData <= std_ulogic_vector(resize(dataInRegister, hRData'length));
      when statusRegisterId  => hRData <= std_ulogic_vector(statusRegister);
      when others => null;
    end case;
  end process selectData;

  hReady <= '1';  -- no wait state
  hResp  <= '0';  -- data OK
  

END ARCHITECTURE masterVersion;




-- VHDL Entity NanoBlaze.nanoProcessor.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 07:38:43 11.11.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY nanoProcessor IS
    GENERIC( 
        addressBitNb           : positive := 8;
        registerBitNb          : positive := 8;
        registerAddressBitNb   : positive := 4;
        programCounterBitNb    : positive := 10;
        stackPointerBitNb      : positive := 5;
        instructionBitNb       : positive := 18;
        scratchpadAddressBitNb : natural  := 4
    );
    PORT( 
        clock       : IN     std_ulogic;
        dataIn      : IN     std_ulogic_vector (registerBitNb-1 DOWNTO 0);
        en          : IN     std_ulogic;
        instruction : IN     std_ulogic_vector (instructionBitNb-1 DOWNTO 0);
        int         : IN     std_uLogic;
        reset       : IN     std_ulogic;
        dataAddress : OUT    unsigned (addressBitNb-1 DOWNTO 0);
        dataOut     : OUT    std_ulogic_vector (registerBitNb-1 DOWNTO 0);
        intAck      : OUT    std_ulogic;
        progCounter : OUT    unsigned ( programCounterBitNb-1 DOWNTO 0 );
        readStrobe  : OUT    std_uLogic;
        writeStrobe : OUT    std_uLogic
    );

-- Declarations

END nanoProcessor ;





-- VHDL Entity NanoBlaze.aluAndRegs.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 07:38:43 11.11.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY aluAndRegs IS
    GENERIC( 
        registerBitNb          : positive := 8;
        registerAddressBitNb   : positive := 4;
        aluCodeBitNb           : positive := 5;
        portAddressBitNb       : positive := 8;
        scratchpadAddressBitNb : natural  := 4
    );
    PORT( 
        addrA           : IN     unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        addrB           : IN     unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        aluCode         : IN     std_ulogic_vector ( aluCodeBitNb-1 DOWNTO 0 );
        cIn             : IN     std_ulogic;
        clock           : IN     std_ulogic;
        instrData       : IN     signed ( registerBitNb-1 DOWNTO 0 );
        instrDataSel    : IN     std_ulogic;
        portIn          : IN     signed ( registerBitNb-1 DOWNTO 0 );
        portInSel       : IN     std_ulogic;
        regWrite        : IN     std_ulogic;
        registerFileSel : IN     std_ulogic;
        reset           : IN     std_ulogic;
        scratchpadSel   : IN     std_ulogic;
        spadIn          : IN     signed ( registerBitNb-1 DOWNTO 0 );
        cOut            : OUT    std_ulogic;
        portAddr        : OUT    unsigned (portAddressBitNb-1 DOWNTO 0);
        portOut         : OUT    signed ( registerBitNb-1 DOWNTO 0 );
        scratchpadAddr  : OUT    unsigned (scratchpadAddressBitNb-1 DOWNTO 0);
        spadOut         : OUT    signed ( registerBitNb-1 DOWNTO 0 );
        zero            : OUT    std_ulogic
    );

-- Declarations

END aluAndRegs ;





-- VHDL Entity NanoBlaze.alu.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:17 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY alu IS
    GENERIC( 
        aluCodeBitNb : positive := 5;
        dataBitNb    : positive := 8
    );
    PORT( 
        aluCode : IN     std_ulogic_vector ( aluCodeBitNb-1 DOWNTO 0 );
        cIn     : IN     std_ulogic;
        opA     : IN     signed ( dataBitNb-1 DOWNTO 0 );
        opB     : IN     signed ( dataBitNb-1 DOWNTO 0 );
        aluOut  : OUT    signed ( dataBitNb-1 DOWNTO 0 );
        cOut    : OUT    std_ulogic;
        zero    : OUT    std_ulogic
    );

-- Declarations

END alu ;





ARCHITECTURE RTL OF alu IS

  signal aluCodeInt: unsigned(aluCode'range);
  signal aArith: signed(opA'high+1 downto 0);
  signal bArith: signed(opA'high+1 downto 0);
  signal cInArith: signed(1 downto 0);
  signal cInShift: std_ulogic;
  signal yArith: signed(aluOut'high+1 downto 0);
  signal aluOutInt: signed(aluOut'range);

BEGIN
  ------------------------------------------------------------------------------
                                      -- clear aluCode don't care LSB for shifts
  aluCodeInt(aluCode'high downto 1) <= unsigned(aluCode(aluCode'high downto 1));

  cleanupLsb: process(aluCode)
  begin
    if aluCode(aluCode'high) = '1' then
      aluCodeInt(0) <= '0';
    else
      aluCodeInt(0) <= aluCode(0);
    end if;
  end process cleanupLsb;

  ------------------------------------------------------------------------------
                                             -- values for arithmetic operations
  aArith <= signed(resize(unsigned(opA), aArith'length));
  bArith <= signed(resize(unsigned(opB), bArith'length));
  cInArith <= (0 => cIn, others => '0');

  process(aluCode, cIn, opA)
  begin
    case aluCode(2 downto 1) is
      when "00"   => cInShift <= cIn;
      when "01"   => cInShift <= opA(opA'high);
      when "10"   => cInShift <= opA(opA'low);
      when "11"   => cInShift <= aluCode(0);
      when others => cInShift <= '-';
    end case;
  end process;

  ------------------------------------------------------------------------------
                                                               -- alu operations
  aluOperation: process(
    aluCodeInt,
    opA, opB,
    aArith, bArith, cInArith,
    cInShift,
    yArith, aluOutInt
  )
    variable xorAcc: std_ulogic;
  begin
    yArith <= (others => '-');
    cOut   <= '-';
    aluOutInt <= (others => '-');
    case to_integer(aluCodeInt) is
      when  0 =>                                        -- LOAD sX, kk
        aluOutInt <= opB;
      when  2 =>                                        -- INPUT sX, pp
        aluOutInt <= opB;
      when  3 =>                                        -- FETCH sX, ss
        aluOutInt <= opB;
      when  5 =>                                        -- AND sX, kk
        aluOutInt <= opA and opB;
        cOut      <= '0';
      when  6 =>                                        -- OR sX, kk
        aluOutInt <= opA or opB;
        cOut      <= '0';
      when  7 =>                                        -- XOR sX, kk
        aluOutInt <= opA xor opB;
        cOut      <= '0';
      when  9 =>                                        -- TEST sX, kk
        aluOutInt <= opA and opB;
        xorAcc := '0';
        for index in aluOutInt'range loop
          xorAcc := xorAcc xor aluOutInt(index);
        end loop;
        cOut      <= xorAcc;
      when 10 =>                                        -- COMPARE sX, kk
        yArith    <= aArith - bArith;
        aluOutInt <= yArith(aluOut'range);
        cOut      <= yArith(yArith'high);
      when 12 =>                                        -- ADD sX, kk
        yArith    <= aArith + bArith;
        aluOutInt <= yArith(aluOut'range);
        cOut      <= yArith(yArith'high);
      when 13 =>                                        -- ADDCY sX, kk
        yArith    <= (aArith + bArith) + cInArith;
        aluOutInt <= yArith(aluOut'range);
        cOut      <= yArith(yArith'high);
      when 14 =>                                        -- SUB sX, kk
        yArith    <= aArith - bArith;
        aluOutInt <= yArith(aluOut'range);
        cOut      <= yArith(yArith'high);
      when 15 =>                                        -- SUBCY sX, kk
        yArith    <= (aArith - bArith) - cInArith;
        aluOutInt <= yArith(aluOut'range);
        cOut      <= yArith(yArith'high);
      when 16 to 23 =>                                  -- SL sX
        aluOutInt <= opA(opA'high-1 downto 0) & cInShift;
        cOut      <= opA(opA'high);
      when 24 to 31 =>                                  -- SR sX
        aluOutInt <= cInShift & opA(opA'high downto 1);
        cOut      <= opA(0);
      when others =>
        aluOutInt <= (others => '-');
    end case;
  end process aluOperation;

  aluOut <= aluOutInt;
  zero <= '1' when aluOutInt = 0 else '0';

END ARCHITECTURE RTL;




-- VHDL Entity NanoBlaze.aluBOpSelector.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:17 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY aluBOpSelector IS
    GENERIC( 
        registerBitNb : positive := 8
    );
    PORT( 
        instrData       : IN     signed ( registerBitNb-1 DOWNTO 0 );
        instrDataSel    : IN     std_ulogic;
        portIn          : IN     signed ( registerBitNb-1 DOWNTO 0 );
        portInSel       : IN     std_ulogic;
        registerFileIn  : IN     signed ( registerBitNb-1 DOWNTO 0 );
        registerFileSel : IN     std_ulogic;
        scratchpadSel   : IN     std_ulogic;
        spadIn          : IN     signed ( registerBitNb-1 DOWNTO 0 );
        opB             : OUT    signed (registerBitNb-1 DOWNTO 0)
    );

-- Declarations

END aluBOpSelector ;





ARCHITECTURE RTL OF aluBOpSelector IS
BEGIN

  selectDataSource: process(
    registerFileSel, registerFileIn,
    scratchpadSel,   spadIn,
    portInSel,       portIn,
    instrDataSel,    instrData
  )
  begin
    if registerFileSel = '1' then
      opB <= registerFileIn;
    elsif scratchpadSel = '1' then
      opB <= spadIn;
    elsif portInSel = '1' then
      opB <= portIn;
    elsif instrDataSel = '1' then
      opB <= instrData;
    else
      opB <= (others => '-');
    end if;
  end process selectDataSource;

END ARCHITECTURE RTL;




-- VHDL Entity NanoBlaze.registerFile.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:17 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY registerFile IS
    GENERIC( 
        registerAddressBitNb : positive := 4;
        dataBitNb            : positive := 8
    );
    PORT( 
        addrA       : IN     unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        addrB       : IN     unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        clock       : IN     std_ulogic;
        regWrite    : IN     std_ulogic;
        registersIn : IN     signed ( dataBitNb-1 DOWNTO 0 );
        reset       : IN     std_ulogic;
        opA         : OUT    signed ( dataBitNb-1 DOWNTO 0 );
        opB         : OUT    signed ( dataBitNb-1 DOWNTO 0 )
    );

-- Declarations

END registerFile ;





ARCHITECTURE RTL OF registerFile IS

  subtype registerType is signed(registersIn'range);
  type registerArrayType is array (0 to 2**registerAddressBitNb-1) of registerType;
  signal registerArray : registerArrayType;

BEGIN
  ------------------------------------------------------------------------------
                                                           -- write to registers
  updateRegister: process(reset, clock)
  begin
    if reset = '1' then
      registerArray <= (others => (others => '0'));
    elsif rising_edge(clock) then
      if regWrite = '1' then
        registerArray(to_integer(addrA)) <= registersIn;
      end if;
    end if;
  end process updateRegister;

  ------------------------------------------------------------------------------
                                                          -- read from registers
  opA <= registerArray(to_integer(addrA));
  opB <= registerArray(to_integer(addrB));

END ARCHITECTURE RTL;




--
-- VHDL Architecture NanoBlaze.aluAndRegs.struct
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 07:38:44 11.11.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY NanoBlaze;

ARCHITECTURE struct OF aluAndRegs IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL aluOut         : signed(registerBitNb-1 DOWNTO 0);
    SIGNAL opA            : signed(registerBitNb-1 DOWNTO 0);
    SIGNAL opB            : signed(registerBitNb-1 DOWNTO 0);
    SIGNAL registerFileIn : signed(registerBitNb-1 DOWNTO 0);


    -- Component Declarations
    COMPONENT alu
    GENERIC (
        aluCodeBitNb : positive := 5;
        dataBitNb    : positive := 8
    );
    PORT (
        aluCode : IN     std_ulogic_vector ( aluCodeBitNb-1 DOWNTO 0 );
        cIn     : IN     std_ulogic ;
        opA     : IN     signed ( dataBitNb-1 DOWNTO 0 );
        opB     : IN     signed ( dataBitNb-1 DOWNTO 0 );
        aluOut  : OUT    signed ( dataBitNb-1 DOWNTO 0 );
        cOut    : OUT    std_ulogic ;
        zero    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT aluBOpSelector
    GENERIC (
        registerBitNb : positive := 8
    );
    PORT (
        instrData       : IN     signed ( registerBitNb-1 DOWNTO 0 );
        instrDataSel    : IN     std_ulogic ;
        portIn          : IN     signed ( registerBitNb-1 DOWNTO 0 );
        portInSel       : IN     std_ulogic ;
        registerFileIn  : IN     signed ( registerBitNb-1 DOWNTO 0 );
        registerFileSel : IN     std_ulogic ;
        scratchpadSel   : IN     std_ulogic ;
        spadIn          : IN     signed ( registerBitNb-1 DOWNTO 0 );
        opB             : OUT    signed (registerBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT registerFile
    GENERIC (
        registerAddressBitNb : positive := 4;
        dataBitNb            : positive := 8
    );
    PORT (
        addrA       : IN     unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        addrB       : IN     unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        clock       : IN     std_ulogic ;
        regWrite    : IN     std_ulogic ;
        registersIn : IN     signed ( dataBitNb-1 DOWNTO 0 );
        reset       : IN     std_ulogic ;
        opA         : OUT    signed ( dataBitNb-1 DOWNTO 0 );
        opB         : OUT    signed ( dataBitNb-1 DOWNTO 0 )
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : alu USE ENTITY NanoBlaze.alu;
--     FOR ALL : aluBOpSelector USE ENTITY NanoBlaze.aluBOpSelector;
--     FOR ALL : registerFile USE ENTITY NanoBlaze.registerFile;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    portOut <= opA;
    spadOut <= opA;

    -- HDL Embedded Text Block 2 eb2
    portAddr <= resize(unsigned(registerFileIn), portAddressBitNb);
    scratchpadAddr <= resize(unsigned(registerFileIn), scratchpadAddressBitNb);


    -- Instance port mappings.
    I_ALU : alu
        GENERIC MAP (
            aluCodeBitNb => aluCodeBitNb,
            dataBitNb    => registerBitNb
        )
        PORT MAP (
            aluCode => aluCode,
            cIn     => cIn,
            opA     => opA,
            opB     => opB,
            aluOut  => aluOut,
            cOut    => cOut,
            zero    => zero
        );
    I_bSel : aluBOpSelector
        GENERIC MAP (
            registerBitNb => registerBitNb
        )
        PORT MAP (
            instrData       => instrData,
            instrDataSel    => instrDataSel,
            portIn          => portIn,
            portInSel       => portInSel,
            registerFileIn  => registerFileIn,
            registerFileSel => registerFileSel,
            scratchpadSel   => scratchpadSel,
            spadIn          => spadIn,
            opB             => opB
        );
    I_regs : registerFile
        GENERIC MAP (
            registerAddressBitNb => registerAddressBitNb,
            dataBitNb            => registerBitNb
        )
        PORT MAP (
            addrA       => addrA,
            addrB       => addrB,
            clock       => clock,
            regWrite    => regWrite,
            registersIn => aluOut,
            reset       => reset,
            opA         => opA,
            opB         => registerFileIn
        );

END struct;




-- VHDL Entity NanoBlaze.branchStack.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:17 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY branchStack IS
    GENERIC( 
        programCounterBitNb : positive := 10;
        stackPointerBitNb   : positive := 5
    );
    PORT( 
        clock             : IN     std_ulogic;
        prevPC            : IN     std_ulogic;
        progCounter       : IN     unsigned ( programCounterBitNb-1 DOWNTO 0 );
        reset             : IN     std_ulogic;
        storePC           : IN     std_ulogic;
        storedProgCounter : OUT    unsigned ( programCounterBitNb-1 DOWNTO 0 )
    );

-- Declarations

END branchStack ;





ARCHITECTURE RTL OF branchStack IS

  subtype progCounterType is unsigned(progCounter'range);
  type progCounterArrayType is array (0 to 2**stackPointerBitNb) of progCounterType;
  signal progCounterArray : progCounterArrayType;

  signal writePointer : unsigned(stackPointerBitNb-1 downto 0);
  signal readPointer  : unsigned(stackPointerBitNb-1 downto 0);

BEGIN
  ------------------------------------------------------------------------------
                                                               -- stack pointers
  updateStackPointer: process(reset, clock)
  begin
    if reset = '1' then
      writePointer <= (others => '0');
    elsif rising_edge(clock) then
      if storePC = '1' then
        writePointer <= writePointer + 1;
      elsif prevPC = '1' then
        writePointer <= writePointer - 1;
      end if;
    end if;
  end process updateStackPointer;

  readPointer <= writePointer - 1;

  ------------------------------------------------------------------------------
                                                       -- program counters stack
  updateStack: process(reset, clock)
  begin
    if rising_edge(clock) then
      if storePc = '1' then
        progCounterArray(to_integer(writePointer)) <= progCounter;
      end if;
      storedProgCounter <= progCounterArray(to_integer(readPointer));
    end if;
  end process updateStack;

END ARCHITECTURE RTL;




-- VHDL Entity NanoBlaze.controller.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:17 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY controller IS
    GENERIC( 
        intCodeBitNb    : positive := 5;
        branchCondBitNb : positive := 3;
        opCodeBitNb     : positive := 5
    );
    PORT( 
        branchCond       : IN     std_ulogic_vector ( branchCondBitNb-1 DOWNTO 0 );
        cOut             : IN     std_ulogic;
        clock            : IN     std_ulogic;
        en               : IN     std_ulogic;
        int              : IN     std_uLogic;
        intCode          : IN     std_ulogic_vector ( intCodeBitNb-1 DOWNTO 0 );
        opCode           : IN     std_ulogic_vector (opCodeBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic;
        twoRegInstr      : IN     std_ulogic;
        zero             : IN     std_ulogic;
        cIn              : OUT    std_ulogic;
        incPC            : OUT    std_ulogic;
        instrDataSel     : OUT    std_ulogic;
        intAck           : OUT    std_ulogic;
        loadInstrAddress : OUT    std_ulogic;
        loadStoredPC     : OUT    std_ulogic;
        portInSel        : OUT    std_ulogic;
        prevPC           : OUT    std_ulogic;
        readStrobe       : OUT    std_uLogic;
        regWrite         : OUT    std_ulogic;
        registerFileSel  : OUT    std_ulogic;
        scratchpadSel    : OUT    std_ulogic;
        scratchpadWrite  : OUT    std_ulogic;
        storePC          : OUT    std_ulogic;
        writeStrobe      : OUT    std_uLogic
    );

-- Declarations

END controller ;





ARCHITECTURE RTL OF controller IS

  signal en1, enInt: std_ulogic;

  constant opCodeLength : integer := 5;
  subtype opCodeType is std_ulogic_vector(opCodeLength-1 downto 0);
  constant opLoad  : opCodeType := "00000";
  constant opInput : opCodeType := "00010";
  constant opFetch : opCodeType := "00011";
  constant opAnd   : opCodeType := "00101";
  constant opOr    : opCodeType := "00110";
  constant opXor   : opCodeType := "00111";
  constant opTest  : opCodeType := "01001";
  constant opComp  : opCodeType := "01010";
  constant opAdd   : opCodeType := "01100";
  constant opAddCy : opCodeType := "01101";
  constant opSub   : opCodeType := "01110";
  constant opSubCy : opCodeType := "01111";
  constant opShRot : opCodeType := "10000";
  constant opRet   : opCodeType := "10101";
  constant opOutput: opCodeType := "10110";
  constant opStore : opCodeType := "10111";
  constant opCall  : opCodeType := "11000";
  constant opJump  : opCodeType := "11010";
  constant opIntF  : opCodeType := "11110";

  constant branchConditionLength : integer := 3;
  subtype branchConditionType is std_ulogic_vector(branchConditionLength-1 downto 0);
  constant brAw  : branchConditionType := "000";
  constant brZ   : branchConditionType := "100";
  constant brNZ  : branchConditionType := "101";
  constant brC   : branchConditionType := "110";
  constant brNC  : branchConditionType := "111";

  signal aluOpSel: std_ulogic;
  signal regWriteEn: std_ulogic;

  signal flagsEn, flagsEnable: std_ulogic;
  signal carrySaved: std_ulogic;
  signal zeroSaved: std_ulogic;

  signal branchEnable1, branchEnable: std_ulogic;
  signal discardOpCode: std_ulogic;

  signal updateIntFlag: std_ulogic;

BEGIN
  ------------------------------------------------------------------------------
                                                                -- Enable signal
  buildEnable: process(reset, clock)
  begin
    if reset = '1' then
      en1 <= '0';
    elsif rising_edge(clock) then
      en1 <= '1';
    end if;
  end process buildEnable;

  enInt <= en1 and en;  -- don't enable very first instruction twice

  ------------------------------------------------------------------------------
                                                                 -- ALU controls
  selectdataSource: process(opCode)
  begin
    aluOpSel      <= '0';
    portInSel     <= '0';
    scratchpadSel <= '0';
    case opCode(opCodeLength-1 downto 0) is
      when opLoad  => aluOpSel      <= '1';
      when opInput => portInSel     <= '1';
      when opFetch => scratchpadSel <= '1';
      when opAnd   => aluOpSel      <= '1';
      when opOr    => aluOpSel      <= '1';
      when opXor   => aluOpSel      <= '1';
      when opTest  => aluOpSel      <= '1';
      when opComp  => aluOpSel      <= '1';
      when opAdd   => aluOpSel      <= '1';
      when opAddCy => aluOpSel      <= '1';
      when opSub   => aluOpSel      <= '1';
      when opSubCy => aluOpSel      <= '1';
      when opShRot => aluOpSel      <= '1';
      when others  => aluOpSel      <= '-';
                      portInSel     <= '-';
                      scratchpadSel <= '-';
    end case;
  end process selectdataSource;

  registerFileSel <= aluOpSel and      twoRegInstr;
  instrDataSel    <= aluOpSel and (not twoRegInstr);

  regWriteEn <= enInt and (not discardOpCode);

  regWriteTable: process(opCode, regWriteEn)
  begin
    case opCode(opCodeLength-1 downto 0) is
      when opLoad  => regWrite <= regWriteEn;
      when opInput => regWrite <= regWriteEn;
      when opFetch => regWrite <= regWriteEn;
      when opAnd   => regWrite <= regWriteEn;
      when opOr    => regWrite <= regWriteEn;
      when opXor   => regWrite <= regWriteEn;
      when opAdd   => regWrite <= regWriteEn;
      when opAddCy => regWrite <= regWriteEn;
      when opSub   => regWrite <= regWriteEn;
      when opSubCy => regWrite <= regWriteEn;
      when opShRot => regWrite <= regWriteEn;
      when others  => regWrite <= '0';
    end case;
  end process regWriteTable;

  ------------------------------------------------------------------------------
                                                                 -- I/O controls
  readStrobe  <= enInt when (opCode = opInput) and (discardOpCode = '0')
    else '0';
  writeStrobe <= enInt when (opCode = opOutput) and (discardOpCode = '0')
    else '0';

  ------------------------------------------------------------------------------
                                                          -- scratchpad controls
  scratchpadWrite <= '1' when opCode = opStore else '0';

  ------------------------------------------------------------------------------
                                                                  -- Carry logic
  flagsEn <= enInt and (not branchEnable);

  flagsEnableTable: process(opCode, flagsEn)
  begin
    case opCode(opCodeLength-1 downto 0) is
      when opAnd   => flagsEnable <= flagsEn;
      when opOr    => flagsEnable <= flagsEn;
      when opXor   => flagsEnable <= flagsEn;
      when opTest  => flagsEnable <= flagsEn;
      when opComp  => flagsEnable <= flagsEn;
      when opAdd   => flagsEnable <= flagsEn;
      when opAddCy => flagsEnable <= flagsEn;
      when opSub   => flagsEnable <= flagsEn;
      when opSubCy => flagsEnable <= flagsEn;
      when opShRot => flagsEnable <= flagsEn;
      when others  => flagsEnable <= '0';
    end case;
  end process flagsEnableTable;

  saveCarries: process(reset, clock)
  begin
    if reset = '1' then
      carrySaved <= '0';
      zeroSaved <= '0';
    elsif rising_edge(clock) then
      if flagsEnable = '1' then
        carrySaved <= cOut;
        zeroSaved <= zero;
      end if;
    end if;
  end process saveCarries;

  cIn <= carrySaved;

  ------------------------------------------------------------------------------
                                                     -- Program counter controls
  checkBranchCondition: process(branchCond, zeroSaved, carrySaved)
  begin
    case branchCond(branchConditionLength-1 downto 0) is
      when brAw => branchEnable1 <= '1';
      when brZ  => branchEnable1 <= zeroSaved;
      when brNZ => branchEnable1 <= not zeroSaved;
      when brC  => branchEnable1 <= carrySaved;
      when brNC => branchEnable1 <= not carrySaved;
      when others => branchEnable1 <= '-';
    end case;
  end process checkBranchCondition;

  branchEnableTable: process(opCode, branchEnable1, discardOpCode)
  begin
    if discardOpCode = '0' then
      case opCode(opCodeLength-1 downto 0) is
        when opRet  => branchEnable <= branchEnable1;
        when opCall => branchEnable <= branchEnable1;
        when opJump => branchEnable <= branchEnable1;
        when others  => branchEnable <= '0';
      end case;
    else
      branchEnable <= '0';
    end if;
  end process branchEnableTable;

  progCounterControlTable: process(opCode, enInt, branchEnable)
  begin
    incPC <= enInt;
    loadInstrAddress <= '0';
    loadStoredPC     <= '0';
    case opCode(opCodeLength-1 downto 0) is
      when opRet  => incPC <= not branchEnable;
                     loadStoredPC <= enInt and branchEnable;
      when opCall => incPC <= not branchEnable;
                     loadInstrAddress <= enInt and branchEnable;
      when opJump => incPC <= not branchEnable;
                     loadInstrAddress <= enInt and branchEnable;
      when others => null;
    end case;
  end process progCounterControlTable;

  -- If a branch condition is met, the next operation has to be discarded.
  -- This is due to the synchronous operation of the program ROM: the
  -- instructions are provided one clock period after the program counter.
  -- so while the branch operation is processed, the next instruction is
  -- already being fetched.
  delayBranchEnable: process(reset, clock)
  begin
    if reset = '1' then
      discardOpCode <= '0';
    elsif rising_edge(clock) then
      discardOpCode <= branchEnable;
    end if;
  end process delayBranchEnable;

  ------------------------------------------------------------------------------
                                                       -- Stack pointer controls
  pcStackControlTable: process(discardOpCode, opCode, enInt)
  begin
    storePC <= '0';
    prevPC  <= '0';
    if discardOpCode = '0' then
      case opCode(opCodeLength-1 downto 0) is
        when opRet  => prevPC <= enInt;
        when opCall => storePC <= enInt;
        when others  => null;
      end case;
    end if;
  end process pcStackControlTable;


  ------------------------------------------------------------------------------
                                                            -- interrupt control
  updateIntFlag <= '1' when opCode = opIntF else '0';

END ARCHITECTURE RTL;




-- VHDL Entity NanoBlaze.instructionDecoder.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:17 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY instructionDecoder IS
    GENERIC( 
        registerBitNb        : positive := 8;
        registerAddressBitNb : positive := 4;
        aluCodeBitNb         : positive := 5;
        instructionBitNb     : positive := 18;
        programCounterBitNb  : positive := 10;
        opCodeBitNb          : positive := 5;
        branchCondBitNb      : positive := 3;
        intCodeBitNb         : positive := 5;
        spadAddressBitNb     : natural  := 4;
        portAddressBitNb     : positive := 8
    );
    PORT( 
        instruction    : IN     std_ulogic_vector ( instructionBitNb-1 DOWNTO 0 );
        addrA          : OUT    unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        addrB          : OUT    unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        aluCode        : OUT    std_ulogic_vector ( aluCodeBitNb-1 DOWNTO 0 );
        branchCond     : OUT    std_ulogic_vector (branchCondBitNb-1 DOWNTO 0);
        instrAddress   : OUT    unsigned ( programCounterBitNb-1 DOWNTO 0 );
        instrData      : OUT    signed ( registerBitNb-1 DOWNTO 0 );
        intCode        : OUT    std_ulogic_vector ( intCodeBitNb-1 DOWNTO 0 );
        opCode         : OUT    std_ulogic_vector ( opCodeBitNb-1 DOWNTO 0 );
        portAddress    : OUT    unsigned (portAddressBitNb-1 DOWNTO 0);
        portIndexedSel : OUT    std_ulogic;
        spadAddress    : OUT    unsigned ( spadAddressBitNb-1 DOWNTO 0 );
        spadIndexedSel : OUT    std_ulogic;
        twoRegInstr    : OUT    std_ulogic
    );

-- Declarations

END instructionDecoder ;





ARCHITECTURE RTL OF instructionDecoder IS

  constant opCodeIndexH         : integer := instruction'high;
  constant opCodeIndexL         : integer := opCodeIndexH - opCodeBitNb + 1;

  constant twoRegInstrIndex     : integer := opCodeIndexL - 1;
  constant ioAddrIndexed        : integer := twoRegInstrIndex;

  constant addrAIndexH          : integer := twoRegInstrIndex - 1;
  constant addrAIndexL          : integer := addrAIndexH - registerAddressBitNb + 1;

  constant immediateDataIndexH  : integer := registerBitNb-1;
  constant immediateDataIndexL  : integer := 0;
  constant addrBIndexH          : integer := addrAIndexL - 1;
  constant addrBIndexL          : integer := addrBIndexH - registerAddressBitNb + 1;

  constant aluCodeIndexH        : integer := opCodeIndexH;
  constant aluCodeIndexL        : integer := aluCodeIndexH - aluCodeBitNb + 1;

  constant portAddressH         : integer := registerBitNb-1;
  constant portAddressL         : integer := portAddressH-portAddressBitNb+1;
  constant spadAddressH         : integer := registerBitNb-1;
  constant spadAddressL         : integer := spadAddressH-spadAddressBitNb+1;

  constant branchCondH          : integer := opCodeIndexL-1;
  constant branchCondL          : integer := branchCondH-branchCondBitNb+1;

BEGIN
  ------------------------------------------------------------------------------
                                                                  -- ALU control
  aluCode <=
    instruction(aluCodeIndexH downto aluCodeIndexL)
      when instruction(aluCodeIndexH) = '0' else
    '1' & instruction(aluCodeBitNb-2 downto 0);
  opCode <= instruction(opCodeIndexH downto opCodeIndexL);
  twoRegInstr <= instruction(twoRegInstrIndex);
  addrA <= unsigned(instruction(addrAIndexH downto addrAIndexL));
  addrB <= unsigned(instruction(addrBIndexH downto addrBIndexL));
  instrData <= signed(instruction(immediateDataIndexH downto immediateDataIndexL));

  ------------------------------------------------------------------------------
                                                                  -- I/O control
  portIndexedSel <= instruction(ioAddrIndexed);
  portAddress <= unsigned(instruction(portAddressH downto portAddressL));

  ------------------------------------------------------------------------------
                                                           -- scratchpad control
  spadIndexedSel <= instruction(ioAddrIndexed);
  spadAddress <= unsigned(instruction(spadAddressH downto spadAddressL));

  ------------------------------------------------------------------------------
                                                               -- branch control
  branchCond <= instruction(branchCondH downto branchCondL);
  instrAddress <= unsigned(instruction(instrAddress'range));

END ARCHITECTURE RTL;




-- VHDL Entity NanoBlaze.programCounter.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:17 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY programCounter IS
    GENERIC( 
        programCounterBitNb : positive := 10
    );
    PORT( 
        clock             : IN     std_ulogic;
        incPC             : IN     std_ulogic;
        instrAddress      : IN     unsigned ( programCounterBitNb-1 DOWNTO 0 );
        loadInstrAddress  : IN     std_ulogic;
        loadStoredPC      : IN     std_ulogic;
        reset             : IN     std_ulogic;
        storedProgCounter : IN     unsigned ( programCounterBitNb-1 DOWNTO 0 );
        progCounter       : OUT    unsigned ( programCounterBitNb-1 DOWNTO 0 )
    );

-- Declarations

END programCounter ;





ARCHITECTURE RTL OF programCounter IS

  signal pCounter: unsigned(progCounter'range);

BEGIN

  updateProgramCounter: process(reset, clock)
  begin
    if reset = '1' then
      pCounter <= (others => '0');
    elsif rising_edge(clock) then
      if incPC = '1' then
        pCounter <= pCounter + 1;
      elsif loadInstrAddress = '1' then
        pCounter <= instrAddress;
      elsif loadStoredPC = '1' then
        pCounter <= storedProgCounter;
      end if;
    end if;
  end process updateProgramCounter;

  progCounter <= pCounter;

END ARCHITECTURE RTL;




-- VHDL Entity NanoBlaze.scratchpad.symbol
--
-- Created:
--          by - zas.UNKNOWN (ZELL)
--          at - 07:22:17 02/18/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY scratchpad IS
    GENERIC( 
        registerBitNb    : positive := 8;
        spadAddressBitNb : natural  := 4
    );
    PORT( 
        addr    : IN     unsigned ( spadAddressBitNb-1 DOWNTO 0 );
        clock   : IN     std_ulogic;
        dataIn  : IN     signed ( registerBitNb-1 DOWNTO 0 );
        reset   : IN     std_ulogic;
        write   : IN     std_ulogic;
        dataOut : OUT    signed ( registerBitNb-1 DOWNTO 0 )
    );

-- Declarations

END scratchpad ;





ARCHITECTURE RTL OF scratchpad IS

  subtype memoryWordType is signed(dataOut'range);
  type memoryArrayType is array (0 to 2**addr'length-1) of memoryWordType;

  signal memoryArray : memoryArrayType;

BEGIN

  process (clock)
  begin
    if rising_edge(clock) then
      if write = '1' then
        memoryArray(to_integer(addr)) <= dataIn;
      end if;
    end if;
  end process;

  dataOut <= memoryArray(to_integer(addr));

END ARCHITECTURE RTL;




--
-- VHDL Architecture NanoBlaze.nanoProcessor.struct
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 07:38:43 11.11.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY NanoBlaze;

ARCHITECTURE struct OF nanoProcessor IS

    -- Architecture declarations
    constant aluCodeBitNb: positive := 5;
    constant opCodeBitNb: positive := 5;
    constant branchCondBitNb: positive := 3;
    constant intCodeBitNb: positive := 5;

    -- Internal signal declarations
    SIGNAL addrA             : unsigned( registerAddressBitNb-1 DOWNTO 0 );
    SIGNAL addrB             : unsigned( registerAddressBitNb-1 DOWNTO 0 );
    SIGNAL aluCode           : std_ulogic_vector( aluCodeBitNb-1 DOWNTO 0 );
    SIGNAL branchCond        : std_ulogic_vector(branchCondBitNb-1 DOWNTO 0);
    SIGNAL cIn               : std_ulogic;
    SIGNAL cOut              : std_ulogic;
    SIGNAL incPC             : std_ulogic;
    SIGNAL instrAddress      : unsigned( programCounterBitNb-1 DOWNTO 0 );
    SIGNAL instrData         : signed( registerBitNb-1 DOWNTO 0 );
    SIGNAL instrDataSel      : std_ulogic;
    SIGNAL instrString       : string(1 TO 16);
    SIGNAL intCode           : std_ulogic_vector( intCodeBitNb-1 DOWNTO 0 );
    SIGNAL loadInstrAddress  : std_ulogic;
    SIGNAL loadStoredPC      : std_ulogic;
    SIGNAL opCode            : std_ulogic_vector( opCodeBitNb-1 DOWNTO 0 );
    SIGNAL portIn            : signed( registerBitNb-1 DOWNTO 0 );
    SIGNAL portInSel         : std_ulogic;
    SIGNAL portIndexedSel    : std_ulogic;
    SIGNAL portInstrAddress  : unsigned(addressBitNb-1 DOWNTO 0);
    SIGNAL portOut           : signed( registerBitNb-1 DOWNTO 0 );
    SIGNAL portRegAddress    : unsigned(addressBitNb-1 DOWNTO 0);
    SIGNAL prevPC            : std_ulogic;
    SIGNAL regWrite          : std_ulogic;
    SIGNAL registerFileSel   : std_ulogic;
    SIGNAL scratchpadSel     : std_ulogic;
    SIGNAL scratchpadWrite   : std_ulogic;
    SIGNAL spadAddress       : unsigned(scratchpadAddressBitNb-1 DOWNTO 0);
    SIGNAL spadIn            : signed(registerBitNb-1 DOWNTO 0);
    SIGNAL spadIndexedSel    : std_ulogic;
    SIGNAL spadInstrAddress  : unsigned(scratchpadAddressBitNb-1 DOWNTO 0);
    SIGNAL spadOut           : signed(registerBitNb-1 DOWNTO 0);
    SIGNAL spadRegAddress    : unsigned(scratchpadAddressBitNb-1 DOWNTO 0);
    SIGNAL storePC           : std_ulogic;
    SIGNAL storedProgCounter : unsigned( programCounterBitNb-1 DOWNTO 0 );
    SIGNAL twoRegInstr       : std_ulogic;
    SIGNAL zero              : std_ulogic;

    -- Implicit buffer signal declarations
    SIGNAL progCounter_internal : unsigned ( programCounterBitNb-1 DOWNTO 0 );


    -- Component Declarations
    COMPONENT aluAndRegs
    GENERIC (
        registerBitNb          : positive := 8;
        registerAddressBitNb   : positive := 4;
        aluCodeBitNb           : positive := 5;
        portAddressBitNb       : positive := 8;
        scratchpadAddressBitNb : natural  := 4
    );
    PORT (
        addrA           : IN     unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        addrB           : IN     unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        aluCode         : IN     std_ulogic_vector ( aluCodeBitNb-1 DOWNTO 0 );
        cIn             : IN     std_ulogic ;
        clock           : IN     std_ulogic ;
        instrData       : IN     signed ( registerBitNb-1 DOWNTO 0 );
        instrDataSel    : IN     std_ulogic ;
        portIn          : IN     signed ( registerBitNb-1 DOWNTO 0 );
        portInSel       : IN     std_ulogic ;
        regWrite        : IN     std_ulogic ;
        registerFileSel : IN     std_ulogic ;
        reset           : IN     std_ulogic ;
        scratchpadSel   : IN     std_ulogic ;
        spadIn          : IN     signed ( registerBitNb-1 DOWNTO 0 );
        cOut            : OUT    std_ulogic ;
        portAddr        : OUT    unsigned (portAddressBitNb-1 DOWNTO 0);
        portOut         : OUT    signed ( registerBitNb-1 DOWNTO 0 );
        scratchpadAddr  : OUT    unsigned (scratchpadAddressBitNb-1 DOWNTO 0);
        spadOut         : OUT    signed ( registerBitNb-1 DOWNTO 0 );
        zero            : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT branchStack
    GENERIC (
        programCounterBitNb : positive := 10;
        stackPointerBitNb   : positive := 5
    );
    PORT (
        clock             : IN     std_ulogic ;
        prevPC            : IN     std_ulogic ;
        progCounter       : IN     unsigned ( programCounterBitNb-1 DOWNTO 0 );
        reset             : IN     std_ulogic ;
        storePC           : IN     std_ulogic ;
        storedProgCounter : OUT    unsigned ( programCounterBitNb-1 DOWNTO 0 )
    );
    END COMPONENT;
    COMPONENT controller
    GENERIC (
        intCodeBitNb    : positive := 5;
        branchCondBitNb : positive := 3;
        opCodeBitNb     : positive := 5
    );
    PORT (
        branchCond       : IN     std_ulogic_vector ( branchCondBitNb-1 DOWNTO 0 );
        cOut             : IN     std_ulogic ;
        clock            : IN     std_ulogic ;
        en               : IN     std_ulogic ;
        int              : IN     std_uLogic ;
        intCode          : IN     std_ulogic_vector ( intCodeBitNb-1 DOWNTO 0 );
        opCode           : IN     std_ulogic_vector (opCodeBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic ;
        twoRegInstr      : IN     std_ulogic ;
        zero             : IN     std_ulogic ;
        cIn              : OUT    std_ulogic ;
        incPC            : OUT    std_ulogic ;
        instrDataSel     : OUT    std_ulogic ;
        intAck           : OUT    std_ulogic ;
        loadInstrAddress : OUT    std_ulogic ;
        loadStoredPC     : OUT    std_ulogic ;
        portInSel        : OUT    std_ulogic ;
        prevPC           : OUT    std_ulogic ;
        readStrobe       : OUT    std_uLogic ;
        regWrite         : OUT    std_ulogic ;
        registerFileSel  : OUT    std_ulogic ;
        scratchpadSel    : OUT    std_ulogic ;
        scratchpadWrite  : OUT    std_ulogic ;
        storePC          : OUT    std_ulogic ;
        writeStrobe      : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT instructionDecoder
    GENERIC (
        registerBitNb        : positive := 8;
        registerAddressBitNb : positive := 4;
        aluCodeBitNb         : positive := 5;
        instructionBitNb     : positive := 18;
        programCounterBitNb  : positive := 10;
        opCodeBitNb          : positive := 5;
        branchCondBitNb      : positive := 3;
        intCodeBitNb         : positive := 5;
        spadAddressBitNb     : natural  := 4;
        portAddressBitNb     : positive := 8
    );
    PORT (
        instruction    : IN     std_ulogic_vector ( instructionBitNb-1 DOWNTO 0 );
        addrA          : OUT    unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        addrB          : OUT    unsigned ( registerAddressBitNb-1 DOWNTO 0 );
        aluCode        : OUT    std_ulogic_vector ( aluCodeBitNb-1 DOWNTO 0 );
        branchCond     : OUT    std_ulogic_vector (branchCondBitNb-1 DOWNTO 0);
        instrAddress   : OUT    unsigned ( programCounterBitNb-1 DOWNTO 0 );
        instrData      : OUT    signed ( registerBitNb-1 DOWNTO 0 );
        intCode        : OUT    std_ulogic_vector ( intCodeBitNb-1 DOWNTO 0 );
        opCode         : OUT    std_ulogic_vector ( opCodeBitNb-1 DOWNTO 0 );
        portAddress    : OUT    unsigned (portAddressBitNb-1 DOWNTO 0);
        portIndexedSel : OUT    std_ulogic ;
        spadAddress    : OUT    unsigned ( spadAddressBitNb-1 DOWNTO 0 );
        spadIndexedSel : OUT    std_ulogic ;
        twoRegInstr    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT programCounter
    GENERIC (
        programCounterBitNb : positive := 10
    );
    PORT (
        clock             : IN     std_ulogic ;
        incPC             : IN     std_ulogic ;
        instrAddress      : IN     unsigned ( programCounterBitNb-1 DOWNTO 0 );
        loadInstrAddress  : IN     std_ulogic ;
        loadStoredPC      : IN     std_ulogic ;
        reset             : IN     std_ulogic ;
        storedProgCounter : IN     unsigned ( programCounterBitNb-1 DOWNTO 0 );
        progCounter       : OUT    unsigned ( programCounterBitNb-1 DOWNTO 0 )
    );
    END COMPONENT;
    COMPONENT scratchpad
    GENERIC (
        registerBitNb    : positive := 8;
        spadAddressBitNb : natural  := 4
    );
    PORT (
        addr    : IN     unsigned ( spadAddressBitNb-1 DOWNTO 0 );
        clock   : IN     std_ulogic ;
        dataIn  : IN     signed ( registerBitNb-1 DOWNTO 0 );
        reset   : IN     std_ulogic ;
        write   : IN     std_ulogic ;
        dataOut : OUT    signed ( registerBitNb-1 DOWNTO 0 )
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : aluAndRegs USE ENTITY NanoBlaze.aluAndRegs;
--     FOR ALL : branchStack USE ENTITY NanoBlaze.branchStack;
--     FOR ALL : controller USE ENTITY NanoBlaze.controller;
--     FOR ALL : instructionDecoder USE ENTITY NanoBlaze.instructionDecoder;
--     FOR ALL : programCounter USE ENTITY NanoBlaze.programCounter;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    dataAddress <= portInstrAddress when portIndexedSel = '0' else portRegAddress;

    -- HDL Embedded Text Block 2 eb2
    dataOut <= std_ulogic_vector(portOut);
    portIn <= signed(dataIn);

    -- HDL Embedded Text Block 3 eb3
    spadAddress <= spadInstrAddress when spadIndexedSel = '0' else spadRegAddress;

    -- HDL Embedded Text Block 4 eb4
    -- pragma translate_off
    
    process(instruction)
    
      constant bitsPerHexDigit : positive := 4;
    
      function pad(inString : string; outLength : positive) return string is
        variable outString : string(1 to outLength);
      begin
        outString := (others => ' ');
        outString(inString'range) := inString;
        return outString;
      end function pad;
    
      function hexDigitNb(bitNb : positive) return positive is
      begin
        return (bitNb-1)/bitsPerHexDigit+1;
      end function hexDigitNb;
    
      variable opCode : unsigned(1+opCodeBitNb-1 downto 0);
      variable destRegister : unsigned(registerAddressBitNb-1 downto 0);
      variable destRegisterString : string(1 to 1+hexDigitNb(registerAddressBitNb));
      variable sourceRegister : unsigned(registerAddressBitNb-1 downto 0);
      variable sourceRegisterString : string(1 to 1+hexDigitNb(registerAddressBitNb));
      variable sourceConstant : unsigned(registerBitNb-1 downto 0);
      variable sourceConstantString : string(1 to hexDigitNb(registerBitNb));
      variable branchAddress : unsigned(programCounterBitNb-1 downto 0);
      variable branchAddressString : string(1 to hexDigitNb(programCounterBitNb));
      variable branchKind : unsigned(1 downto 0);
      variable shRotCin : unsigned(2 downto 0);
      variable shRotDir: std_ulogic;
    
      function toHexDigit(binary : unsigned(bitsPerHexDigit-1 downto 0)) return character is
      begin
        if binary <= 9 then
          return character'val(character'pos('0') + to_integer(to_01(binary)));
        else
          return character'val(character'pos('A') + to_integer(to_01(binary)) - 10);
        end if;
      end function toHexDigit;
    
      function toHexString(binary : unsigned) return string is
        variable hexString : string(1 to hexDigitNb(binary'length));
      begin
        for index in hexString'high-1 downto 0 loop
          hexString(hexString'high-index) := toHexDigit(
            resize(shift_right(binary, bitsPerHexDigit*index), bitsPerHexDigit)
          );
        end loop;
        return hexString;
      end function toHexString;
    
    begin
    
      opCode := resize(
        shift_right(unsigned(instruction), instruction'length-opCode'length),
        opCode'length
      );
      destRegister := resize(
        shift_right(unsigned(instruction), instruction'length-opCode'length-destRegister'length),
        destRegister'length
      );
      destRegisterString := 's' & toHexDigit(destRegister);
      sourceRegister := resize(
        shift_right(unsigned(instruction), instruction'length-opCode'length-destRegister'length-sourceRegister'length),
        sourceRegister'length
      );
      sourceRegisterString := 's' & toHexDigit(sourceRegister);
      sourceConstant := resize(unsigned(instruction), sourceConstant'length);
      sourceConstantString := toHexString(sourceConstant);
      branchKind := resize(
        shift_right(unsigned(instruction), instruction'length-opCode'length-branchKind'length),
        branchKind'length
      );
      branchAddress := resize(unsigned(instruction), branchAddress'length);
      branchAddressString := toHexString(branchAddress);
      shRotCin := resize(shift_right(unsigned(instruction), 1), shRotCin'length);
      shRotDir := instruction(0);
    
      case opCode is
        when "000000" => instrString <= pad("LOAD " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "000001" => instrString <= pad("LOAD " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "000100" => instrString <= pad("INPUT " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "000101" => instrString <= pad("INPUT " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "000110" => instrString <= pad("FETCH " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "000111" => instrString <= pad("FETCH " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "001010" => instrString <= pad("AND " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "001011" => instrString <= pad("AND " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "001100" => instrString <= pad("OR " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "001101" => instrString <= pad("OR " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "001110" => instrString <= pad("XOR " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "001111" => instrString <= pad("XOR " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "010010" => instrString <= pad("TEST " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "010011" => instrString <= pad("TEST " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "010100" => instrString <= pad("COMP " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "010101" => instrString <= pad("COMP " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "011000" => instrString <= pad("ADD " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "011001" => instrString <= pad("ADD " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "011010" => instrString <= pad("ADDCY " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "011011" => instrString <= pad("ADDCY " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "011100" => instrString <= pad("SUB " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "011101" => instrString <= pad("SUB " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "011110" => instrString <= pad("SUBCY " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "011111" => instrString <= pad("SUBCY " & destRegisterString & " " & sourceRegisterString, instrString'length);
        when "100000" =>
          case shRotCin is
            when "000"  => instrString <= pad("SLA " & destRegisterString, instrString'length);
            when "001"  => instrString <= pad("RL " & destRegisterString, instrString'length);
            when "010"  => instrString <= pad("SLX " & destRegisterString, instrString'length);
            when "011"  =>
              case shRotDir is
                when '0'    => instrString <= pad("SL0 " & destRegisterString, instrString'length);
                when '1'    => instrString <= pad("SL1 " & destRegisterString, instrString'length);
                when others => instrString <= pad("--------", instrString'length);
              end case;
            when "100"  => instrString <= pad("SRA " & destRegisterString, instrString'length);
            when "101"  => instrString <= pad("SRX " & destRegisterString, instrString'length);
            when "110"  => instrString <= pad("RR " & destRegisterString, instrString'length);
            when "111"  =>
              case shRotDir is
                when '0'    => instrString <= pad("SR0 " & destRegisterString, instrString'length);
                when '1'    => instrString <= pad("SR1 " & destRegisterString, instrString'length);
                when others => instrString <= pad("--------", instrString'length);
              end case;
            when others => instrString <= pad("--------", instrString'length);
          end case;
        when "101100" => instrString <= pad("OUTPUT " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "101101" => instrString <= pad("OUTPUT " & destRegisterString & " (" & sourceRegisterString & ")", instrString'length);
        when "101110" => instrString <= pad("STORE " & destRegisterString & " " & sourceConstantString, instrString'length);
        when "101111" => instrString <= pad("STORE " & destRegisterString & " (" & sourceRegisterString & ")", instrString'length);
        when "101010" => instrString <= pad("RET", instrString'length);
        when "101011" =>
          case branchKind is
            when "00"   => instrString <= pad("RET Z", instrString'length);
            when "01"   => instrString <= pad("RET NZ", instrString'length);
            when "10"   => instrString <= pad("RET C", instrString'length);
            when "11"   => instrString <= pad("RET NC", instrString'length);
            when others => instrString <= pad("--------", instrString'length);
          end case;
        when "110000" => instrString <= pad("CALL " & branchAddressString, instrString'length);
        when "110001" =>
          case branchKind is
            when "00"   => instrString <= pad("CALL Z " & branchAddressString, instrString'length);
            when "01"   => instrString <= pad("CALL NZ " & branchAddressString, instrString'length);
            when "10"   => instrString <= pad("CALL C " & branchAddressString, instrString'length);
            when "11"   => instrString <= pad("CALL NC " & branchAddressString, instrString'length);
            when others => instrString <= pad("--------", instrString'length);
          end case;
        when "110100" => instrString <= pad("JUMP " & branchAddressString, instrString'length);
        when "110101" =>
          case branchKind is
            when "00"   => instrString <= pad("JUMP Z " & branchAddressString, instrString'length);
            when "01"   => instrString <= pad("JUMP NZ " & branchAddressString, instrString'length);
            when "10"   => instrString <= pad("JUMP C " & branchAddressString, instrString'length);
            when "11"   => instrString <= pad("JUMP NC " & branchAddressString, instrString'length);
            when others => instrString <= pad("--------", instrString'length);
          end case;
        when others   => instrString <= pad("--------", instrString'length);
      end case;
    
    end process;
    
    -- pragma translate_on
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


    -- Instance port mappings.
    I_alu : aluAndRegs
        GENERIC MAP (
            registerBitNb          => registerBitNb,
            registerAddressBitNb   => registerAddressBitNb,
            aluCodeBitNb           => aluCodeBitNb,
            portAddressBitNb       => addressBitNb,
            scratchpadAddressBitNb => scratchpadAddressBitNb
        )
        PORT MAP (
            addrA           => addrA,
            addrB           => addrB,
            aluCode         => aluCode,
            cIn             => cIn,
            clock           => clock,
            instrData       => instrData,
            instrDataSel    => instrDataSel,
            portIn          => portIn,
            portInSel       => portInSel,
            regWrite        => regWrite,
            registerFileSel => registerFileSel,
            reset           => reset,
            scratchpadSel   => scratchpadSel,
            spadIn          => spadIn,
            cOut            => cOut,
            portAddr        => portRegAddress,
            portOut         => portOut,
            scratchpadAddr  => spadRegAddress,
            spadOut         => spadOut,
            zero            => zero
        );
    I_BR : branchStack
        GENERIC MAP (
            programCounterBitNb => programCounterBitNb,
            stackPointerBitNb   => stackPointerBitNb
        )
        PORT MAP (
            clock             => clock,
            prevPC            => prevPC,
            progCounter       => progCounter_internal,
            reset             => reset,
            storePC           => storePC,
            storedProgCounter => storedProgCounter
        );
    I_ctrl : controller
        GENERIC MAP (
            intCodeBitNb    => 5,
            branchCondBitNb => branchCondBitNb,
            opCodeBitNb     => opCodeBitNb
        )
        PORT MAP (
            branchCond       => branchCond,
            cOut             => cOut,
            clock            => clock,
            en               => en,
            int              => int,
            intCode          => intCode,
            opCode           => opCode,
            reset            => reset,
            twoRegInstr      => twoRegInstr,
            zero             => zero,
            cIn              => cIn,
            incPC            => incPC,
            instrDataSel     => instrDataSel,
            intAck           => intAck,
            loadInstrAddress => loadInstrAddress,
            loadStoredPC     => loadStoredPC,
            portInSel        => portInSel,
            prevPC           => prevPC,
            readStrobe       => readStrobe,
            regWrite         => regWrite,
            registerFileSel  => registerFileSel,
            scratchpadSel    => scratchpadSel,
            scratchpadWrite  => scratchpadWrite,
            storePC          => storePC,
            writeStrobe      => writeStrobe
        );
    I_instr : instructionDecoder
        GENERIC MAP (
            registerBitNb        => registerBitNb,
            registerAddressBitNb => registerAddressBitNb,
            aluCodeBitNb         => aluCodeBitNb,
            instructionBitNb     => instructionBitNb,
            programCounterBitNb  => programCounterBitNb,
            opCodeBitNb          => opCodeBitNb,
            branchCondBitNb      => branchCondBitNb,
            intCodeBitNb         => 5,
            spadAddressBitNb     => scratchpadAddressBitNb,
            portAddressBitNb     => addressBitNb
        )
        PORT MAP (
            instruction    => instruction,
            addrA          => addrA,
            addrB          => addrB,
            aluCode        => aluCode,
            branchCond     => branchCond,
            instrAddress   => instrAddress,
            instrData      => instrData,
            intCode        => intCode,
            opCode         => opCode,
            portAddress    => portInstrAddress,
            portIndexedSel => portIndexedSel,
            spadAddress    => spadInstrAddress,
            spadIndexedSel => spadIndexedSel,
            twoRegInstr    => twoRegInstr
        );
    I_PC : programCounter
        GENERIC MAP (
            programCounterBitNb => programCounterBitNb
        )
        PORT MAP (
            clock             => clock,
            incPC             => incPC,
            instrAddress      => instrAddress,
            loadInstrAddress  => loadInstrAddress,
            loadStoredPC      => loadStoredPC,
            reset             => reset,
            storedProgCounter => storedProgCounter,
            progCounter       => progCounter_internal
        );

    g_scratchpad: IF scratchpadAddressBitNb > 0 GENERATE
    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : scratchpad USE ENTITY NanoBlaze.scratchpad;
    -- pragma synthesis_on

    BEGIN
        I_sPad : scratchpad
            GENERIC MAP (
                registerBitNb    => registerBitNb,
                spadAddressBitNb => scratchpadAddressBitNb
            )
            PORT MAP (
                addr    => spadAddress,
                clock   => clock,
                dataIn  => spadOut,
                reset   => reset,
                write   => scratchpadWrite,
                dataOut => spadIn
            );
    END;
    END GENERATE g_scratchpad;

    -- Implicit buffered output assignments
    progCounter <= progCounter_internal;

END struct;




--
-- VHDL Architecture SystemOnChip.beamerSoc.struct
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:29:59 04/15/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;
-- LIBRARY AhbLite;
  use work.ahbLite.all;

-- LIBRARY AhbLiteComponents;
-- LIBRARY NanoBlaze;
-- LIBRARY SystemOnChip;

ARCHITECTURE struct OF beamerSoc IS

    -- Architecture declarations
    constant programCounterBitNb: positive := 10;
    constant instructionBitNb: positive := 26;
    constant stackPointerBitNb: positive := 4;
    constant registerAddressBitNb: positive := 4;
    constant scratchpadAddressBitNb: natural := 0;
    
    constant signalBitNb: positive := 16;
    constant updatePeriodBitNb : positive := 16;
    
    constant gpioIndex: positive := 1;
    constant uartIndex: positive := gpioIndex+1;
    constant beamerIndex: positive := uartIndex+1;
    
    constant ahbMemoryLocation : ahbMemoryLocationVector := (
      gpioIndex => (
        baseAddress => 16#0000#,
        addressMask => 16#10000# - 16#0002#
      ),
      uartIndex => (
        baseAddress => 16#0010#,
        addressMask => 16#10000# - 16#0004#
      ),
      beamerIndex => (
        baseAddress => 16#0020#,
        addressMask => 16#10000# - 16#0004#
      ),
      others => (
        baseAddress => 16#FFFF#,
        addressMask => 16#0000#
      )
    );

    -- Internal signal declarations
    SIGNAL upEn           : std_ulogic;
    SIGNAL int            : std_uLogic;
    SIGNAL upAddress      : unsigned(ahbAddressBitNb-1 DOWNTO 0);
    SIGNAL upDataOut      : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL upDataIn       : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL upReadStrobe   : std_uLogic;
    SIGNAL upWriteStrobe  : std_uLogic;
    SIGNAL hAddr          : unsigned(ahbAddressBitNb-1 DOWNTO 0);
    SIGNAL hWData         : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL hRData         : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL hTrans         : std_ulogic_vector(ahbTransBitNb-1 DOWNTO 0);
    SIGNAL hSize          : std_ulogic_vector(ahbSizeBitNb-1 DOWNTO 0);
    SIGNAL hBurst         : std_ulogic_vector(ahbBurstBitNb-1 DOWNTO 0);
    SIGNAL hProt          : std_ulogic_vector(ahbProtBitNb-1 DOWNTO 0);
    SIGNAL hWrite         : std_uLogic;
    SIGNAL hReady         : std_uLogic;
    SIGNAL hMastLock      : std_uLogic;
    SIGNAL hResp          : std_uLogic;
    SIGNAL hClk           : std_uLogic;
    SIGNAL hReset_n       : std_uLogic;
    SIGNAL hSelV          : std_ulogic_vector(1 TO ahbSlaveNb);
    SIGNAL hRDataV        : ahbDataVector;
    SIGNAL hReadyV        : std_logic_vector(1 TO ahbSlaveNb);
    SIGNAL hRespV         : std_logic_vector(1 TO ahbSlaveNb);
    SIGNAL hSelGpio       : std_uLogic;
    SIGNAL hRespGpio      : std_uLogic;
    SIGNAL hReadyGpio     : std_uLogic;
    SIGNAL hRDataGpio     : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL hRDataBeamer   : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL hRDataUart     : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL hSelBeamer     : std_uLogic;
    SIGNAL hSelUart       : std_uLogic;
    SIGNAL hRespUart      : std_uLogic;
    SIGNAL hRespBeamer    : std_uLogic;
    SIGNAL hReadyBeamer   : std_uLogic;
    SIGNAL hReadyUart     : std_uLogic;
    SIGNAL intAck         : std_ulogic;
    SIGNAL instruction    : std_ulogic_vector(instructionBitNb-1 DOWNTO 0);
    SIGNAL programCounter : unsigned(programCounterBitNb-1 DOWNTO 0);


    -- Component Declarations
    COMPONENT ahbDecoder
    GENERIC (
        ahbMemoryLocation : ahbMemoryLocationVector
    );
    PORT (
        hAddr : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hSel  : OUT    std_ulogic_vector (1 TO ahbSlaveNb)
    );
    END COMPONENT;
    COMPONENT ahbMasterInterface
    PORT (
        clock        : IN     std_ulogic ;
        hRData       : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady       : IN     std_uLogic ;
        hResp        : IN     std_uLogic ;
        pAddress     : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        pDataOut     : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        pReadStrobe  : IN     std_uLogic ;
        pWriteStrobe : IN     std_uLogic ;
        reset        : IN     std_ulogic ;
        hAddr        : OUT    unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hBurst       : OUT    std_ulogic_vector (ahbBurstBitNb-1 DOWNTO 0);
        hClk         : OUT    std_uLogic ;
        hMastLock    : OUT    std_uLogic ;
        hProt        : OUT    std_ulogic_vector (ahbProtBitNb-1 DOWNTO 0);
        hReset_n     : OUT    std_uLogic ;
        hSize        : OUT    std_ulogic_vector (ahbSizeBitNb-1 DOWNTO 0);
        hTrans       : OUT    std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWData       : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hWrite       : OUT    std_uLogic ;
        pDataIn      : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT ahbMultiplexor
    PORT (
        hRDataV : IN     ahbDataVector ;
        hReadyV : IN     std_logic_vector (1 TO ahbSlaveNb);
        hRespV  : IN     std_logic_vector (1 TO ahbSlaveNb);
        hSel    : IN     std_ulogic_vector ( 1 TO ahbSlaveNb );
        hRData  : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady  : OUT    std_uLogic ;
        hResp   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT ahbMuxConnector
    GENERIC (
        index : positive := 1
    );
    PORT (
        hRData  : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady  : IN     std_uLogic ;
        hResp   : IN     std_uLogic ;
        hSelV   : IN     std_ulogic_vector ( 1 TO ahbSlaveNb );
        hRDataV : OUT    ahbDataVector ;
        hReadyV : OUT    std_logic_vector (1 TO ahbSlaveNb);
        hRespV  : OUT    std_logic_vector (1 TO ahbSlaveNb);
        hSel    : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT ahbGpio
    GENERIC (
        ioNb : positive := 8
    );
    PORT (
        hAddr    : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hClk     : IN     std_uLogic ;
        hReset_n : IN     std_uLogic ;
        hSel     : IN     std_uLogic ;
        hTrans   : IN     std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWData   : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hWrite   : IN     std_uLogic ;
        ioIn     : IN     std_ulogic_vector (ioNb-1 DOWNTO 0);
        hRData   : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady   : OUT    std_uLogic ;
        hResp    : OUT    std_uLogic ;
        ioEn     : OUT    std_ulogic_vector (ioNb-1 DOWNTO 0);
        ioOut    : OUT    std_ulogic_vector (ioNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT ahbUart
    GENERIC (
        txFifoDepth : positive := 8;
        rxFifoDepth : positive := 1
    );
    PORT (
        RxD      : IN     std_ulogic ;
        hAddr    : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hClk     : IN     std_uLogic ;
        hReset_n : IN     std_uLogic ;
        hSel     : IN     std_uLogic ;
        hTrans   : IN     std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWData   : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hWrite   : IN     std_uLogic ;
        TxD      : OUT    std_ulogic ;
        hRData   : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady   : OUT    std_uLogic ;
        hResp    : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT nanoProcessor
    GENERIC (
        addressBitNb           : positive := 8;
        registerBitNb          : positive := 8;
        registerAddressBitNb   : positive := 4;
        programCounterBitNb    : positive := 10;
        stackPointerBitNb      : positive := 5;
        instructionBitNb       : positive := 18;
        scratchpadAddressBitNb : natural  := 4
    );
    PORT (
        clock       : IN     std_ulogic ;
        dataIn      : IN     std_ulogic_vector (registerBitNb-1 DOWNTO 0);
        en          : IN     std_ulogic ;
        instruction : IN     std_ulogic_vector (instructionBitNb-1 DOWNTO 0);
        int         : IN     std_uLogic ;
        reset       : IN     std_ulogic ;
        dataAddress : OUT    unsigned (addressBitNb-1 DOWNTO 0);
        dataOut     : OUT    std_ulogic_vector (registerBitNb-1 DOWNTO 0);
        intAck      : OUT    std_ulogic ;
        progCounter : OUT    unsigned ( programCounterBitNb-1 DOWNTO 0 );
        readStrobe  : OUT    std_uLogic ;
        writeStrobe : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT ahbBeamer
    GENERIC (
        patternAddressBitNb : positive := 9;
        testOutBitNb        : positive := 16
    );
    PORT (
        outX      : OUT    std_ulogic ;
        hAddr     : IN     unsigned (ahbAddressBitNb-1 DOWNTO 0);
        outY      : OUT    std_ulogic ;
        hWData    : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        selSinCos : IN     std_ulogic ;
        testOut   : OUT    std_ulogic_vector (1 TO testOutBitNb);
        hRData    : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hTrans    : IN     std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWrite    : IN     std_ulogic ;
        hSel      : IN     std_ulogic ;
        hReady    : OUT    std_ulogic ;
        hResp     : OUT    std_ulogic ;
        hClk      : IN     std_ulogic ;
        hReset_n  : IN     std_ulogic 
    );
    END COMPONENT;
    COMPONENT programRom
    GENERIC (
        addressBitNb : positive := 8;
        dataBitNb    : positive := 8
    );
    PORT (
        address : IN     unsigned (addressBitNb-1 DOWNTO 0);
        clock   : IN     std_ulogic ;
        en      : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector ( dataBitNb-1 DOWNTO 0 )
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : ahbBeamer USE ENTITY SystemOnChip.ahbBeamer;
--     FOR ALL : ahbDecoder USE ENTITY AhbLite.ahbDecoder;
--     FOR ALL : ahbGpio USE ENTITY AhbLiteComponents.ahbGpio;
--     FOR ALL : ahbMasterInterface USE ENTITY AhbLite.ahbMasterInterface;
--     FOR ALL : ahbMultiplexor USE ENTITY AhbLite.ahbMultiplexor;
--     FOR ALL : ahbMuxConnector USE ENTITY AhbLite.ahbMuxConnector;
--     FOR ALL : ahbUart USE ENTITY AhbLiteComponents.ahbUart;
--     FOR ALL : nanoProcessor USE ENTITY NanoBlaze.nanoProcessor;
--     FOR ALL : programRom USE ENTITY SystemOnChip.programRom;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    upEn <= '1';


    -- Instance port mappings.
    I_dec : ahbDecoder
        GENERIC MAP (
            ahbMemoryLocation => ahbMemoryLocation
        )
        PORT MAP (
            hAddr => hAddr,
            hSel  => hSelV
        );
    I_mst : ahbMasterInterface
        PORT MAP (
            clock        => clock,
            hRData       => hRData,
            hReady       => hReady,
            hResp        => hResp,
            pAddress     => upAddress,
            pDataOut     => upDataOut,
            pReadStrobe  => upReadStrobe,
            pWriteStrobe => upWriteStrobe,
            reset        => reset,
            hAddr        => hAddr,
            hBurst       => hBurst,
            hClk         => hClk,
            hMastLock    => hMastLock,
            hProt        => hProt,
            hReset_n     => hReset_n,
            hSize        => hSize,
            hTrans       => hTrans,
            hWData       => hWData,
            hWrite       => hWrite,
            pDataIn      => upDataIn
        );
    I_mux : ahbMultiplexor
        PORT MAP (
            hRDataV => hRDataV,
            hReadyV => hReadyV,
            hRespV  => hRespV,
            hSel    => hSelV,
            hRData  => hRData,
            hReady  => hReady,
            hResp   => hResp
        );
    I_connBeam : ahbMuxConnector
        GENERIC MAP (
            index => beamerIndex
        )
        PORT MAP (
            hRData  => hRDataBeamer,
            hReady  => hReadyBeamer,
            hResp   => hRespBeamer,
            hSelV   => hSelV,
            hRDataV => hRDataV,
            hReadyV => hReadyV,
            hRespV  => hRespV,
            hSel    => hSelBeamer
        );
    I_connT : ahbMuxConnector
        GENERIC MAP (
            index => gpioIndex
        )
        PORT MAP (
            hRData  => hRDataGpio,
            hReady  => hReadyGpio,
            hResp   => hRespGpio,
            hSelV   => hSelV,
            hRDataV => hRDataV,
            hReadyV => hReadyV,
            hRespV  => hRespV,
            hSel    => hSelGpio
        );
    I_connUart : ahbMuxConnector
        GENERIC MAP (
            index => uartIndex
        )
        PORT MAP (
            hRData  => hRDataUart,
            hReady  => hReadyUart,
            hResp   => hRespUart,
            hSelV   => hSelV,
            hRDataV => hRDataV,
            hReadyV => hReadyV,
            hRespV  => hRespV,
            hSel    => hSelUart
        );
    I_GPIO : ahbGpio
        GENERIC MAP (
            ioNb => ioNb
        )
        PORT MAP (
            hAddr    => hAddr,
            hClk     => hClk,
            hReset_n => hReset_n,
            hSel     => hSelGpio,
            hTrans   => hTrans,
            hWData   => hWData,
            hWrite   => hWrite,
            ioIn     => ioIn,
            hRData   => hRDataGpio,
            hReady   => hReadyGpio,
            hResp    => hRespGpio,
            ioEn     => ioEn,
            ioOut    => ioOut
        );
    I_UART : ahbUart
        GENERIC MAP (
            txFifoDepth => 8,
            rxFifoDepth => 1
        )
        PORT MAP (
            RxD      => RxD,
            hAddr    => hAddr,
            hClk     => hClk,
            hReset_n => hReset_n,
            hSel     => hSelUart,
            hTrans   => hTrans,
            hWData   => hWData,
            hWrite   => hWrite,
            TxD      => TxD,
            hRData   => hRDataUart,
            hReady   => hReadyUart,
            hResp    => hRespUart
        );
    I_up : nanoProcessor
        GENERIC MAP (
            addressBitNb           => ahbAddressBitNb,
            registerBitNb          => ahbDataBitNb,
            registerAddressBitNb   => registerAddressBitNb,
            programCounterBitNb    => programCounterBitNb,
            stackPointerBitNb      => stackPointerBitNb,
            instructionBitNb       => instructionBitNb,
            scratchpadAddressBitNb => scratchpadAddressBitNb
        )
        PORT MAP (
            clock       => clock,
            dataIn      => upDataIn,
            en          => upEn,
            instruction => instruction,
            int         => int,
            reset       => reset,
            dataAddress => upAddress,
            dataOut     => upDataOut,
            intAck      => intAck,
            progCounter => programCounter,
            readStrobe  => upReadStrobe,
            writeStrobe => upWriteStrobe
        );
    I_beamer : ahbBeamer
        GENERIC MAP (
            patternAddressBitNb => patternAddressBitNb,
            testOutBitNb        => testOutBitNb
        )
        PORT MAP (
            outX      => outX,
            hAddr     => hAddr,
            outY      => outY,
            hWData    => hWData,
            selSinCos => selSinCos,
            testOut   => testOut,
            hRData    => hRDataBeamer,
            hTrans    => hTrans,
            hWrite    => hWrite,
            hSel      => hSelBeamer,
            hReady    => hReadyBeamer,
            hResp     => hRespBeamer,
            hClk      => hClk,
            hReset_n  => hReset_n
        );
    I_rom : programRom
        GENERIC MAP (
            addressBitNb => programCounterBitNb,
            dataBitNb    => instructionBitNb
        )
        PORT MAP (
            address => programCounter,
            clock   => clock,
            en      => upEn,
            reset   => reset,
            dataOut => instruction
        );

END struct;




--
-- VHDL Architecture Board.FPGA_beamer.struct
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 14:55:16 04/15/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY Board;
-- LIBRARY SystemOnChip;

ARCHITECTURE struct OF FPGA_beamer IS

    -- Architecture declarations
    constant ioNb: positive := 8;
    constant testOutBitNb: positive := 16;
    constant patternAddressBitNb: positive := 9;

    -- Internal signal declarations
    SIGNAL ioIn           : std_ulogic_vector(ioNb-1 DOWNTO 0);
    SIGNAL logic1         : std_uLogic;
    SIGNAL reset          : std_ulogic;
    SIGNAL resetSynch     : std_ulogic;
    SIGNAL resetSynch_N   : std_ulogic;
    SIGNAL rxdSynch       : std_ulogic;
    SIGNAL selSinCos      : std_ulogic;
    SIGNAL selSinCosSynch : std_ulogic;
    SIGNAL testOut        : std_ulogic_vector(1 TO testOutBitNb);


    -- Component Declarations
    COMPONENT DFF
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT inverterIn
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT beamerSoc
    GENERIC (
        ioNb                : positive := 8;
        testOutBitNb        : positive := 16;
        patternAddressBitNb : positive := 9
    );
    PORT (
        TxD       : OUT    std_ulogic ;
        RxD       : IN     std_ulogic ;
        outX      : OUT    std_ulogic ;
        outY      : OUT    std_ulogic ;
        selSinCos : IN     std_ulogic ;
        reset     : IN     std_ulogic ;
        clock     : IN     std_ulogic ;
        ioEn      : OUT    std_ulogic_vector (ioNb-1 DOWNTO 0);
        ioOut     : OUT    std_ulogic_vector (ioNb-1 DOWNTO 0);
        ioIn      : IN     std_ulogic_vector (ioNb-1 DOWNTO 0);
        testOut   : OUT    std_ulogic_vector (1 TO testOutBitNb)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : DFF USE ENTITY Board.DFF;
--     FOR ALL : beamerSoc USE ENTITY SystemOnChip.beamerSoc;
--     FOR ALL : inverterIn USE ENTITY Board.inverterIn;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 2 eb2
    LED1 <= testOut(1);
    LED2 <= testOut(2);
    spare(testOut'range) <= testOut;
    spare(testOut'high+1 to spare'high) <= (others => '0');

    -- HDL Embedded Text Block 3 eb3
    logic1 <= '1';


    -- Instance port mappings.
    I8 : DFF
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => rxd0,
            Q   => rxdSynch
        );
    I9 : DFF
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => selSinCos,
            Q   => selSinCosSynch
        );
    I12 : DFF
        PORT MAP (
            CLK => clock,
            CLR => reset,
            D   => logic1,
            Q   => resetSynch_N
        );
    I2 : inverterIn
        PORT MAP (
            in1  => reset_N,
            out1 => reset
        );
    I3 : inverterIn
        PORT MAP (
            in1  => resetSynch_N,
            out1 => resetSynch
        );
    I7 : inverterIn
        PORT MAP (
            in1  => selSinCos_n,
            out1 => selSinCos
        );
    I_top : beamerSoc
        GENERIC MAP (
            ioNb                => ioNb,
            testOutBitNb        => testOutBitNb,
            patternAddressBitNb => patternAddressBitNb
        )
        PORT MAP (
            TxD       => txd0,
            RxD       => rxdSynch,
            outX      => xOut,
            outY      => yOut,
            selSinCos => selSinCosSynch,
            reset     => resetSynch,
            clock     => clock,
            ioEn      => OPEN,
            ioOut     => OPEN,
            ioIn      => ioIn,
            testOut   => testOut
        );

END struct;




